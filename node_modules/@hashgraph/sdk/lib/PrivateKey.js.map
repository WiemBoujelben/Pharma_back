{"version":3,"file":"PrivateKey.js","sources":["../src/PrivateKey.js"],"sourcesContent":["// SPDX-License-Identifier: Apache-2.0\n\nimport { PrivateKey as PrivateKeyCrypto } from \"@hashgraph/cryptography\";\nimport Mnemonic from \"./Mnemonic.js\";\nimport PublicKey from \"./PublicKey.js\";\nimport Key from \"./Key.js\";\nimport CACHE from \"./Cache.js\";\nimport SignatureMap from \"./transaction/SignatureMap.js\";\n\nimport AccountId from \"./account/AccountId.js\";\nimport TransactionId from \"./transaction/TransactionId.js\";\nimport { proto } from \"@hashgraph/proto\";\n\n/**\n * @typedef {import(\"./transaction/Transaction.js\").default} Transaction\n */\n\n/**\n * @namespace proto\n * @typedef {import(\"@hashgraph/proto\").proto.IKey} HieroProto.proto.IKey\n * @typedef {import(\"@hashgraph/proto\").proto.ITransaction} HieroProto.proto.ITransaction\n * @typedef {import(\"@hashgraph/proto\").proto.ISignaturePair} HieroProto.proto.ISignaturePair\n * @typedef {import(\"@hashgraph/proto\").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction\n * @typedef {import(\"@hashgraph/proto\").proto.TransactionBody} HieroProto.proto.TransactionBody\n */\n\nexport default class PrivateKey extends Key {\n    /**\n     * @internal\n     * @hideconstructor\n     * @param {PrivateKeyCrypto} key\n     */\n    constructor(key) {\n        super();\n\n        this._key = key;\n    }\n\n    /**\n     * Generate a random Ed25519 private key.\n     *\n     * @returns {PrivateKey}\n     */\n    static generateED25519() {\n        return new PrivateKey(PrivateKeyCrypto.generateED25519());\n    }\n\n    /**\n     * Generate a random EDSA private key.\n     *\n     * @returns {PrivateKey}\n     */\n    static generateECDSA() {\n        return new PrivateKey(PrivateKeyCrypto.generateECDSA());\n    }\n\n    /**\n     * Depredated - Use `generateED25519()` instead\n     * Generate a random Ed25519 private key.\n     *\n     * @returns {PrivateKey}\n     */\n    static generate() {\n        return PrivateKey.generateED25519();\n    }\n\n    /**\n     * Depredated - Use `generateED25519Async()` instead\n     * Generate a random Ed25519 private key.\n     *\n     * @returns {Promise<PrivateKey>}\n     */\n    static async generateAsync() {\n        return new PrivateKey(await PrivateKeyCrypto.generateAsync());\n    }\n\n    /**\n     * Generate a random Ed25519 private key.\n     *\n     * @returns {Promise<PrivateKey>}\n     */\n    static async generateED25519Async() {\n        return new PrivateKey(await PrivateKeyCrypto.generateED25519Async());\n    }\n\n    /**\n     * Generate a random ECDSA private key.\n     *\n     * @returns {Promise<PrivateKey>}\n     */\n    static async generateECDSAAsync() {\n        return new PrivateKey(await PrivateKeyCrypto.generateECDSAAsync());\n    }\n\n    /**\n     * Construct a private key from bytes. Requires DER header.\n     *\n     * @param {Uint8Array} data\n     * @returns {PrivateKey}\n     */\n    static fromBytes(data) {\n        return new PrivateKey(PrivateKeyCrypto.fromBytes(data));\n    }\n\n    /**\n     * Construct a ECDSA private key from bytes.\n     *\n     * @param {Uint8Array} data\n     * @returns {PrivateKey}\n     */\n    static fromBytesECDSA(data) {\n        return new PrivateKey(PrivateKeyCrypto.fromBytesECDSA(data));\n    }\n\n    /**\n     * Construct a ED25519 private key from bytes.\n     *\n     * @param {Uint8Array} data\n     * @returns {PrivateKey}\n     */\n    static fromBytesED25519(data) {\n        return new PrivateKey(PrivateKeyCrypto.fromBytesED25519(data));\n    }\n\n    /**\n     * @deprecated - Use fromStringECDSA() or fromStringED2551() on a HEX-encoded string\n     * and fromStringDer() on a HEX-encoded string with DER prefix instead.\n     * Construct a private key from a hex-encoded string. Requires DER header.\n     * @param {string} text\n     * @returns {PrivateKey}\n     */\n    static fromString(text) {\n        return new PrivateKey(PrivateKeyCrypto.fromString(text));\n    }\n\n    /**\n     * Construct a private key from a HEX-encoded string with a der prefix\n     *\n     * @param {string} text\n     * @returns {PrivateKey}\n     */\n    static fromStringDer(text) {\n        return new PrivateKey(PrivateKeyCrypto.fromString(text));\n    }\n\n    /**\n     * Construct a ECDSA private key from a hex-encoded string.\n     *\n     * @param {string} text\n     * @returns {PrivateKey}\n     */\n    static fromStringECDSA(text) {\n        return new PrivateKey(PrivateKeyCrypto.fromStringECDSA(text));\n    }\n\n    /**\n     * Construct a Ed25519 private key from a hex-encoded string.\n     *\n     * @param {string} text\n     * @returns {PrivateKey}\n     */\n    static fromStringED25519(text) {\n        return new PrivateKey(PrivateKeyCrypto.fromStringED25519(text));\n    }\n\n    /**\n     * Construct a Ed25519 private key from a Uint8Array seed.\n     *\n     * @param {Uint8Array} seed\n     * @returns {Promise<PrivateKey>}\n     */\n    static async fromSeedED25519(seed) {\n        return new PrivateKey(await PrivateKeyCrypto.fromSeedED25519(seed));\n    }\n\n    /**\n     * Construct a Ed25519 private key from a Uint8Array seed.\n     *\n     * @param {Uint8Array} seed\n     * @returns {Promise<PrivateKey>}\n     */\n    static async fromSeedECDSAsecp256k1(seed) {\n        return new PrivateKey(\n            await PrivateKeyCrypto.fromSeedECDSAsecp256k1(seed),\n        );\n    }\n\n    /**\n     * @deprecated - Use `Mnemonic.from[Words|String]().to[Ed25519|Ecdsa]PrivateKey()` instead\n     *\n     * Recover a private key from a mnemonic phrase (and optionally a password).\n     * @param {Mnemonic  | string} mnemonic\n     * @param {string} [passphrase]\n     * @returns {Promise<PrivateKey>}\n     */\n    static async fromMnemonic(mnemonic, passphrase = \"\") {\n        if (mnemonic instanceof Mnemonic) {\n            return new PrivateKey(\n                // eslint-disable-next-line deprecation/deprecation\n                await PrivateKeyCrypto.fromMnemonic(\n                    mnemonic._mnemonic,\n                    passphrase,\n                ),\n            );\n        }\n\n        return new PrivateKey(\n            // eslint-disable-next-line deprecation/deprecation\n            await PrivateKeyCrypto.fromMnemonic(mnemonic, passphrase),\n        );\n    }\n\n    /**\n     * Recover a private key from a keystore, previously created by `.toKeystore()`.\n     *\n     * This key will _not_ support child key derivation.\n     *\n     * @param {Uint8Array} data\n     * @param {string} [passphrase]\n     * @returns {Promise<PrivateKey>}\n     * @throws {cryptography.BadKeyError} If the passphrase is incorrect or the hash fails to validate.\n     */\n    static async fromKeystore(data, passphrase = \"\") {\n        return new PrivateKey(\n            await PrivateKeyCrypto.fromKeystore(data, passphrase),\n        );\n    }\n\n    /**\n     * Recover a private key from a pem string; the private key may be encrypted.\n     *\n     * This method assumes the .pem file has been converted to a string already.\n     *\n     * If `passphrase` is not null or empty, this looks for the first `ENCRYPTED PRIVATE KEY`\n     * section and uses `passphrase` to decrypt it; otherwise, it looks for the first `PRIVATE KEY`\n     * section and decodes that as a DER-encoded  private key.\n     *\n     * @param {string} data\n     * @param {string} [passphrase]\n     * @returns {Promise<PrivateKey>}\n     */\n    static async fromPem(data, passphrase = \"\") {\n        return new PrivateKey(await PrivateKeyCrypto.fromPem(data, passphrase));\n    }\n\n    /**\n     * Derive a new private key at the given wallet index.\n     *\n     * Only currently supported for keys created with `fromMnemonic()`; other keys will throw\n     * an error.\n     *\n     * You can check if a key supports derivation with `.supportsDerivation()`\n     *\n     * @param {number} index\n     * @returns {Promise<PrivateKey>}\n     * @throws If this key does not support derivation.\n     */\n    async derive(index) {\n        return new PrivateKey(await this._key.derive(index));\n    }\n\n    /**\n     * @param {number} index\n     * @returns {Promise<PrivateKey>}\n     * @throws If this key does not support derivation.\n     */\n    async legacyDerive(index) {\n        return new PrivateKey(await this._key.legacyDerive(index));\n    }\n\n    /**\n     * Get the public key associated with this private key.\n     *\n     * The public key can be freely given and used by other parties to verify\n     * the signatures generated by this private key.\n     *\n     * @returns {PublicKey}\n     */\n    get publicKey() {\n        return new PublicKey(this._key.publicKey);\n    }\n\n    /**\n     * Get the public key associated with this private key.\n     *\n     * The public key can be freely given and used by other parties to verify\n     * the signatures generated by this private key.\n     *\n     * @returns {?Uint8Array}\n     */\n    get chainCode() {\n        return this._key._chainCode;\n    }\n\n    /**\n     * Sign a message with this private key.\n     *\n     * @param {Uint8Array} bytes\n     * @returns {Uint8Array} - The signature bytes without the message\n     */\n    sign(bytes) {\n        return this._key.sign(bytes);\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @returns {SignatureMap}\n     */\n    signTransaction(transaction) {\n        const sigMap = new SignatureMap();\n\n        for (const signedTx of transaction._signedTransactions.list) {\n            const bodyBytes = signedTx.bodyBytes;\n            if (!bodyBytes) throw new Error(\"Body bytes are missing\");\n\n            const body = proto.TransactionBody.decode(bodyBytes);\n            if (!body.transactionID || !body.nodeAccountID) {\n                throw new Error(\n                    \"Transaction ID or Node Account ID not found in the signed transaction\",\n                );\n            }\n\n            const nodeId = AccountId._fromProtobuf(body.nodeAccountID);\n            const transactionId = TransactionId._fromProtobuf(\n                body.transactionID,\n            );\n            const sig = this._key.sign(bodyBytes);\n            sigMap.addSignature(nodeId, transactionId, this.publicKey, sig);\n        }\n\n        transaction.addSignature(this.publicKey, sigMap);\n        return sigMap;\n    }\n    /**\n     * Check if `derive` can be called on this private key.\n     *\n     * This is only the case if the key was created from a mnemonic.\n     *\n     * @returns {boolean}\n     */\n    isDerivable() {\n        return this._key.isDerivable();\n    }\n\n    /**\n     * @returns {Uint8Array}\n     */\n    toBytes() {\n        return this._key.toBytes();\n    }\n\n    /**\n     * @returns {Uint8Array}\n     */\n    toBytesDer() {\n        return this._key.toBytesDer();\n    }\n\n    /**\n     * @returns {Uint8Array}\n     */\n    toBytesRaw() {\n        return this._key.toBytesRaw();\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return this._key.toStringDer();\n    }\n\n    /**\n     * @returns {string}\n     */\n    toStringDer() {\n        return this._key.toStringDer();\n    }\n\n    /**\n     * @returns {string}\n     */\n    toStringRaw() {\n        return this._key.toStringRaw();\n    }\n\n    /**\n     * Create a keystore with a given passphrase.\n     *\n     * The key can be recovered later with `fromKeystore()`.\n     *\n     * Note that this will not retain the ancillary data used for\n     * deriving child keys, thus `.derive()` on the restored key will\n     * throw even if this instance supports derivation.\n     *\n     * @param {string} [passphrase]\n     * @returns {Promise<Uint8Array>}\n     */\n    toKeystore(passphrase = \"\") {\n        return this._key.toKeystore(passphrase);\n    }\n\n    /**\n     * @returns {HieroProto.proto.IKey}\n     */\n    _toProtobufKey() {\n        return this.publicKey._toProtobufKey();\n    }\n\n    /**\n     * @param {Long | number} shard\n     * @param {Long | number} realm\n     * @returns {AccountId}\n     */\n    toAccountId(shard, realm) {\n        return this.publicKey.toAccountId(shard, realm);\n    }\n\n    /**\n     * @returns {string}\n     */\n    get type() {\n        return this._key._type;\n    }\n}\n\nCACHE.setPrivateKeyConstructor((key) => new PrivateKey(key));\n"],"names":["PrivateKey","Key","constructor","key","super","this","_key","generateED25519","PrivateKeyCrypto","generateECDSA","generate","generateAsync","generateED25519Async","generateECDSAAsync","fromBytes","data","fromBytesECDSA","fromBytesED25519","fromString","text","fromStringDer","fromStringECDSA","fromStringED25519","fromSeedED25519","seed","fromSeedECDSAsecp256k1","fromMnemonic","mnemonic","passphrase","Mnemonic","_mnemonic","fromKeystore","fromPem","derive","index","legacyDerive","publicKey","PublicKey","chainCode","_chainCode","sign","bytes","signTransaction","transaction","sigMap","SignatureMap","signedTx","_signedTransactions","list","bodyBytes","Error","body","proto","TransactionBody","decode","transactionID","nodeAccountID","nodeId","AccountId","_fromProtobuf","transactionId","TransactionId","sig","addSignature","isDerivable","toBytes","toBytesDer","toBytesRaw","toString","toStringDer","toStringRaw","toKeystore","_toProtobufKey","toAccountId","shard","realm","type","_type","CACHE","setPrivateKeyConstructor"],"mappings":"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"}