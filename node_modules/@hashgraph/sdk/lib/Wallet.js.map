{"version":3,"file":"Wallet.js","sources":["../src/Wallet.js"],"sourcesContent":["// SPDX-License-Identifier: Apache-2.0\n\nimport PrivateKey from \"./PrivateKey.js\";\nimport AccountId from \"./account/AccountId.js\";\nimport SignerSignature from \"./SignerSignature.js\";\nimport AccountBalanceQuery from \"./account/AccountBalanceQuery.js\";\nimport AccountInfoQuery from \"./account/AccountInfoQuery.js\";\nimport AccountRecordsQuery from \"./account/AccountRecordsQuery.js\";\nimport TransactionId from \"./transaction/TransactionId.js\";\nimport * as util from \"./util.js\";\n\n/**\n * @template RequestT\n * @template ResponseT\n * @template OutputT\n * @typedef {import(\"./Executable.js\").default<RequestT, ResponseT, OutputT>} Executable<RequestT, ResponseT, OutputT>\n */\n\n/**\n * @typedef {import(\"./Signer.js\").Signer} Signer\n * @typedef {import(\"./Provider.js\").Provider} Provider\n * @typedef {import(\"./LedgerId.js\").default} LedgerId\n * @typedef {import(\"./Key.js\").default} Key\n * @typedef {import(\"./transaction/Transaction.js\").default} Transaction\n * @typedef {import(\"./transaction/TransactionResponse.js\").default} TransactionResponse\n * @typedef {import(\"./transaction/TransactionReceipt.js\").default} TransactionReceipt\n * @typedef {import(\"./transaction/TransactionRecord.js\").default} TransactionRecord\n * @typedef {import(\"./account/AccountBalance.js\").default} AccountBalance\n * @typedef {import(\"./account/AccountInfo.js\").default} AccountInfo\n */\n\n/**\n * @template {any} O\n * @typedef {import(\"./query/Query.js\").default<O>} Query<O>\n */\n\n/**\n * @implements {Signer}\n */\nexport default class Wallet {\n    /**\n     * NOTE: When using string for private key, the string needs to contain DER headers\n     *\n     * @param {AccountId | string} accountId\n     * @param {PrivateKey | string} privateKey\n     * @param {Provider=} provider\n     */\n    constructor(accountId, privateKey, provider) {\n        const key =\n            typeof privateKey === \"string\"\n                ? PrivateKey.fromStringDer(privateKey)\n                : privateKey;\n\n        this.publicKey = key.publicKey;\n        /**\n         * @type {(message: Uint8Array) => Promise<Uint8Array>}\n         */\n        this.signer = (message) => Promise.resolve(key.sign(message));\n        this.provider = provider;\n        this.accountId =\n            typeof accountId === \"string\"\n                ? AccountId.fromString(accountId)\n                : accountId;\n    }\n\n    /**\n     * @returns {Promise<Wallet>}\n     * @deprecated\n     */\n    static createRandomED25519() {\n        const privateKey = PrivateKey.generateED25519();\n        const publicKey = privateKey.publicKey;\n        const accountId = publicKey.toAccountId(0, 0);\n        return Promise.resolve(new Wallet(accountId, privateKey));\n    }\n\n    /**\n     * @returns {Promise<Wallet>}\n     * @deprecated\n     */\n    static createRandomECDSA() {\n        const privateKey = PrivateKey.generateECDSA();\n        const publicKey = privateKey.publicKey;\n        const accountId = publicKey.toAccountId(0, 0);\n        return Promise.resolve(new Wallet(accountId, privateKey));\n    }\n\n    /**\n     * @returns {Provider=}\n     */\n    getProvider() {\n        return this.provider;\n    }\n\n    /**\n     * @abstract\n     * @returns {AccountId}\n     */\n    getAccountId() {\n        return this.accountId;\n    }\n\n    /**\n     * @returns {Key}\n     */\n    getAccountKey() {\n        return this.publicKey;\n    }\n\n    /**\n     * @returns {LedgerId?}\n     */\n    getLedgerId() {\n        return this.provider == null ? null : this.provider.getLedgerId();\n    }\n\n    /**\n     * @abstract\n     * @returns {{[key: string]: (string | AccountId)}}\n     */\n    getNetwork() {\n        return this.provider == null ? {} : this.provider.getNetwork();\n    }\n\n    /**\n     * @abstract\n     * @returns {string[]}\n     */\n    getMirrorNetwork() {\n        return this.provider == null ? [] : this.provider.getMirrorNetwork();\n    }\n\n    /**\n     * @param {Uint8Array[]} messages\n     * @returns {Promise<SignerSignature[]>}\n     */\n    async sign(messages) {\n        const sigantures = [];\n\n        for (const message of messages) {\n            sigantures.push(\n                new SignerSignature({\n                    publicKey: this.publicKey,\n                    signature: await this.signer(message),\n                    accountId: this.accountId,\n                }),\n            );\n        }\n\n        return sigantures;\n    }\n\n    /**\n     * @returns {Promise<AccountBalance>}\n     */\n    getAccountBalance() {\n        return this.call(\n            new AccountBalanceQuery().setAccountId(this.accountId),\n        );\n    }\n\n    /**\n     * @abstract\n     * @returns {Promise<AccountInfo>}\n     */\n    getAccountInfo() {\n        return this.call(new AccountInfoQuery().setAccountId(this.accountId));\n    }\n\n    /**\n     * @abstract\n     * @returns {Promise<TransactionRecord[]>}\n     */\n    getAccountRecords() {\n        return this.call(\n            new AccountRecordsQuery().setAccountId(this.accountId),\n        );\n    }\n\n    /**\n     * @template {Transaction} T\n     * @param {T} transaction\n     * @returns {Promise<T>}\n     */\n    signTransaction(transaction) {\n        return transaction.signWith(this.publicKey, this.signer);\n    }\n\n    /**\n     * @template {Transaction} T\n     * @param {T} transaction\n     * @returns {Promise<T>}\n     */\n    checkTransaction(transaction) {\n        const transactionId = transaction.transactionId;\n        if (\n            transactionId != null &&\n            transactionId.accountId != null &&\n            transactionId.accountId.compare(this.accountId) != 0\n        ) {\n            throw new Error(\n                \"transaction's ID constructed with a different account ID\",\n            );\n        }\n\n        if (this.provider == null) {\n            return Promise.resolve(transaction);\n        }\n\n        const nodeAccountIds = (\n            transaction.nodeAccountIds != null ? transaction.nodeAccountIds : []\n        ).map((nodeAccountId) => nodeAccountId.toString());\n        const network = Object.values(this.provider.getNetwork()).map(\n            (nodeAccountId) => nodeAccountId.toString(),\n        );\n\n        if (\n            !nodeAccountIds.reduce(\n                (previous, current) => previous && network.includes(current),\n                true,\n            )\n        ) {\n            throw new Error(\n                \"Transaction already set node account IDs to values not within the current network\",\n            );\n        }\n\n        return Promise.resolve(transaction);\n    }\n\n    /**\n     * @template {Transaction} T\n     * @param {T} transaction\n     * @returns {Promise<T>}\n     */\n    populateTransaction(transaction) {\n        transaction._freezeWithAccountId(this.accountId);\n\n        if (transaction.transactionId == null) {\n            transaction.setTransactionId(\n                TransactionId.generate(this.accountId),\n            );\n        }\n\n        if (\n            transaction.nodeAccountIds != null &&\n            transaction.nodeAccountIds.length != 0\n        ) {\n            return Promise.resolve(transaction.freeze());\n        }\n\n        if (this.provider == null) {\n            return Promise.resolve(transaction);\n        }\n\n        const nodeAccountIds = Object.values(this.provider.getNetwork()).map(\n            (id) => (typeof id === \"string\" ? AccountId.fromString(id) : id),\n        );\n        util.shuffle(nodeAccountIds);\n        transaction.setNodeAccountIds(\n            nodeAccountIds.slice(0, (nodeAccountIds.length + 3 - 1) / 3),\n        );\n\n        return Promise.resolve(transaction.freeze());\n    }\n\n    /**\n     * @template RequestT\n     * @template ResponseT\n     * @template OutputT\n     * @param {Executable<RequestT, ResponseT, OutputT>} request\n     * @returns {Promise<OutputT>}\n     */\n    call(request) {\n        if (this.provider == null) {\n            throw new Error(\n                \"cannot send request with an wallet that doesn't contain a provider\",\n            );\n        }\n\n        return this.provider.call(\n            request._setOperatorWith(\n                this.accountId,\n                this.publicKey,\n                this.signer,\n            ),\n        );\n    }\n}\n"],"names":["Wallet","constructor","accountId","privateKey","provider","key","PrivateKey","fromStringDer","this","publicKey","signer","message","Promise","resolve","sign","AccountId","fromString","createRandomED25519","generateED25519","toAccountId","createRandomECDSA","generateECDSA","getProvider","getAccountId","getAccountKey","getLedgerId","getNetwork","getMirrorNetwork","messages","sigantures","push","SignerSignature","signature","getAccountBalance","call","AccountBalanceQuery","setAccountId","getAccountInfo","AccountInfoQuery","getAccountRecords","AccountRecordsQuery","signTransaction","transaction","signWith","checkTransaction","transactionId","compare","Error","nodeAccountIds","map","nodeAccountId","toString","network","Object","values","reduce","previous","current","includes","populateTransaction","_freezeWithAccountId","setTransactionId","TransactionId","generate","length","freeze","id","util.shuffle","setNodeAccountIds","slice","request","_setOperatorWith"],"mappings":"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"}