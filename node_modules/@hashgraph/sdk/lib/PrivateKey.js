import{PrivateKey as t}from"@hashgraph/cryptography";import e from"./Mnemonic.js";import r from"./PublicKey.js";import n from"./Key.js";import o from"./Cache.js";import i from"./transaction/SignatureMap.js";import s from"./account/AccountId.js";import a from"./transaction/TransactionId.js";import{proto as c}from"@hashgraph/proto";class y extends n{constructor(t){super(),this._key=t}static generateED25519(){return new y(t.generateED25519())}static generateECDSA(){return new y(t.generateECDSA())}static generate(){return y.generateED25519()}static async generateAsync(){return new y(await t.generateAsync())}static async generateED25519Async(){return new y(await t.generateED25519Async())}static async generateECDSAAsync(){return new y(await t.generateECDSAAsync())}static fromBytes(e){return new y(t.fromBytes(e))}static fromBytesECDSA(e){return new y(t.fromBytesECDSA(e))}static fromBytesED25519(e){return new y(t.fromBytesED25519(e))}static fromString(e){return new y(t.fromString(e))}static fromStringDer(e){return new y(t.fromString(e))}static fromStringECDSA(e){return new y(t.fromStringECDSA(e))}static fromStringED25519(e){return new y(t.fromStringED25519(e))}static async fromSeedED25519(e){return new y(await t.fromSeedED25519(e))}static async fromSeedECDSAsecp256k1(e){return new y(await t.fromSeedECDSAsecp256k1(e))}static async fromMnemonic(r,n=""){return new y(r instanceof e?await t.fromMnemonic(r._mnemonic,n):await t.fromMnemonic(r,n))}static async fromKeystore(e,r=""){return new y(await t.fromKeystore(e,r))}static async fromPem(e,r=""){return new y(await t.fromPem(e,r))}async derive(t){return new y(await this._key.derive(t))}async legacyDerive(t){return new y(await this._key.legacyDerive(t))}get publicKey(){return new r(this._key.publicKey)}get chainCode(){return this._key._chainCode}sign(t){return this._key.sign(t)}signTransaction(t){const e=new i;for(const r of t._signedTransactions.list){const t=r.bodyBytes;if(!t)throw new Error("Body bytes are missing");const n=c.TransactionBody.decode(t);if(!n.transactionID||!n.nodeAccountID)throw new Error("Transaction ID or Node Account ID not found in the signed transaction");const o=s._fromProtobuf(n.nodeAccountID),i=a._fromProtobuf(n.transactionID),y=this._key.sign(t);e.addSignature(o,i,this.publicKey,y)}return t.addSignature(this.publicKey,e),e}isDerivable(){return this._key.isDerivable()}toBytes(){return this._key.toBytes()}toBytesDer(){return this._key.toBytesDer()}toBytesRaw(){return this._key.toBytesRaw()}toString(){return this._key.toStringDer()}toStringDer(){return this._key.toStringDer()}toStringRaw(){return this._key.toStringRaw()}toKeystore(t=""){return this._key.toKeystore(t)}_toProtobufKey(){return this.publicKey._toProtobufKey()}toAccountId(t,e){return this.publicKey.toAccountId(t,e)}get type(){return this._key._type}}o.setPrivateKeyConstructor((t=>new y(t)));export{y as default};
//# sourceMappingURL=PrivateKey.js.map
