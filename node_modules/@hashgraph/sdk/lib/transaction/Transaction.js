import t from"../Hbar.js";import n from"./TransactionResponse.js";import s from"./TransactionId.js";import i from"./TransactionHashMap.js";import e from"./SignatureMap.js";import o,{ExecutionState as r}from"../Executable.js";import a from"../Status.js";import c from"long";import{digest as h}from"../cryptography/sha384.js";import{encode as u}from"../encoding/hex.js";import*as d from"@hashgraph/proto";import l from"../PrecheckStatusError.js";import _ from"../account/AccountId.js";import g from"../PublicKey.js";import f from"./List.js";import p from"../Timestamp.js";import{compare as m}from"../util.js";import T from"./CustomFeeLimit.js";const y=c.fromValue(7776e3),I=t.fromTinybars(c.fromString("9223372036854775807")),b=1024,w=new Map;class S extends o{constructor(){super(),this._transactions=new f,this._signedTransactions=new f,this._signerPublicKeys=new Set,this._transactionValidDuration=120,this._defaultMaxTransactionFee=new t(2),this._customFeeLimits=[],this._maxTransactionFee=null,this._transactionMemo="",this._transactionIds=new f,this._publicKeys=[],this._transactionSigners=[],this._regenerateTransactionId=null}static fromBytes(t){const n=[],i=[],e=[],o=[],r=[],a=[],c=d.proto.TransactionList.decode(t).transactionList;if(0===c.length){const n=d.proto.Transaction.decode(t);0!==n.signedTransactionBytes.length?c.push(n):c.push({signedTransactionBytes:d.proto.SignedTransaction.encode({sigMap:n.sigMap,bodyBytes:n.bodyBytes}).finish()})}for(const t of c){if(null==t.bodyBytes&&null==t.signedTransactionBytes)throw new Error("bodyBytes and signedTransactionBytes are null");if(t.bodyBytes&&0!=t.bodyBytes.length){const n=d.proto.TransactionBody.decode(t.bodyBytes);if(null!=n.transactionID){const t=s._fromProtobuf(n.transactionID);o.includes(t.toString())||(i.push(t),o.push(t.toString()))}if(null!=n.nodeAccountID){const t=_._fromProtobuf(n.nodeAccountID);r.includes(t.toString())||(e.push(t),r.push(t.toString()))}if(null==n.data)throw new Error("(BUG) body.data was not set in the protobuf");a.push(n)}if(t.signedTransactionBytes&&0!=t.signedTransactionBytes.length){const c=d.proto.SignedTransaction.decode(t.signedTransactionBytes);n.push(c);const h=d.proto.TransactionBody.decode(c.bodyBytes);if(null!=h.transactionID){const t=s._fromProtobuf(h.transactionID);o.includes(t.toString())||(i.push(t),o.push(t.toString()))}if(null!=h.nodeAccountID){const t=_._fromProtobuf(h.nodeAccountID);r.includes(t.toString())||(e.push(t),r.push(t.toString()))}if(null==h.data)throw new Error("(BUG) body.data was not set in the protobuf");a.push(h)}}const h=a[0];if(null==h||null==h.data)throw new Error("No transaction found in bytes or failed to decode TransactionBody");const u=w.get(h.data);if(null==u)throw new Error(`(BUG) Transaction.fromBytes() not implemented for type ${h.data}`);return u(c,n,i,e,a)}schedule(){if(this._requireNotFrozen(),1!=A.length)throw new Error("ScheduleCreateTransaction has not been loaded yet");return A[0]()._setScheduledTransaction(this)}static _fromProtobufTransactions(n,s,i,e,o,r){const a=r[0];for(let t=0;t<e.length;t++)for(let n=0;n<o.length-1;n++)if(!m(r[t*o.length+n],r[t*o.length+n+1],new Set(["nodeAccountID"])))throw new Error("failed to validate transaction bodies");const h=new _(0);for(let t=0;t<o.length;t++)o[t].equals(h)&&o.splice(t--,1);n._transactions.setList(s),n._signedTransactions.setList(i),n._transactionIds.setList(e),n._nodeAccountIds.setList(o),n._transactionValidDuration=null!=a.transactionValidDuration&&null!=a.transactionValidDuration.seconds?c.fromValue(a.transactionValidDuration.seconds).toInt():120,n._maxTransactionFee=null!=a.transactionFee&&a.transactionFee>new c(0,0,!0)?t.fromTinybars(a.transactionFee):null,n._customFeeLimits=null!=a.maxCustomFees?a.maxCustomFees?.map((t=>T._fromProtobuf(t))):[],n._transactionMemo=null!=a.memo?a.memo:"";for(let t=0;t<o.length;t++){const e=i[t]||s[t];if(null!=e.sigMap&&null!=e.sigMap.sigPair)for(const t of e.sigMap.sigPair)n._signerPublicKeys.add(u(t.pubKeyPrefix)),n._publicKeys.push(g.fromBytes(t.pubKeyPrefix)),n._transactionSigners.push(null)}return n}setNodeAccountIds(t){return this._requireNotFrozen(),super.setNodeAccountIds(t),this}get transactionValidDuration(){return this._transactionValidDuration}setTransactionValidDuration(t){return this._requireNotFrozen(),this._transactionValidDuration=t,this}get maxTransactionFee(){return this._maxTransactionFee}setMaxTransactionFee(n){return this._requireNotFrozen(),this._maxTransactionFee=n instanceof t?n:new t(n),this}get regenerateTransactionId(){return this._regenerateTransactionId}setRegenerateTransactionId(t){return this._requireNotFrozen(),this._regenerateTransactionId=t,this}get transactionMemo(){return this._transactionMemo}setTransactionMemo(t){return this._requireNotFrozen(),this._transactionMemo=t,this}get transactionId(){return this._transactionIds.isEmpty?null:(this._transactionIds.setLocked(),this._transactionIds.current)}setTransactionId(t){return this._requireNotFrozen(),this._transactionIds.setList([t]).setLocked(),this}getRequiredChunks(){return 1}sign(t){return this.signWith(t.publicKey,(n=>Promise.resolve(t.sign(n))))}async signWith(t,n){this._signOnDemand||this._requireFrozen();const s=t.toBytesRaw(),i=u(s);if(this._signerPublicKeys.has(i))return this;if(this._transactions.clear(),this._signerPublicKeys.add(i),this._signOnDemand)return this._publicKeys.push(t),this._transactionSigners.push(n),this;this._transactionIds.setLocked(),this._nodeAccountIds.setLocked();for(const s of this._signedTransactions.list){const i=s.bodyBytes,e=await n(i);null==s.sigMap&&(s.sigMap={}),null==s.sigMap.sigPair&&(s.sigMap.sigPair=[]),s.sigMap.sigPair.push(t._toProtobufSignature(e))}return this}signWithOperator(t){const n=t._operator;if(null==n)throw new Error("`client` must have an operator to sign with the operator");return this._isFrozen()||this.freezeWith(t),this.signWith(n.publicKey,n.transactionSigner)}addSignature(t,n){this.isFrozen()||this.freeze();const i=t.toBytesRaw(),e=u(i);if(this._signerPublicKeys.has(e))return this;this._transactions.clear(),this._transactionIds.setLocked(),this._nodeAccountIds.setLocked(),this._signedTransactions.setLocked();for(let i=0;i<this._signedTransactions.length;i++){const e=this._signedTransactions.get(i);if(null==e.sigMap&&(e.sigMap={}),null==e.sigMap.sigPair&&(e.sigMap.sigPair=[]),e.bodyBytes){const{transactionID:i,nodeAccountID:o}=d.proto.TransactionBody.decode(e.bodyBytes);if(!i||!o)throw new Error("Transaction ID or Node Account ID not found in the signed transaction");const r=s._fromProtobuf(i),a=_._fromProtobuf(o),c=n.get(a),h=c?.get(r),u=h?.get(t);if(!u)throw new Error("Signature not found for the transaction and public key");const l=t._toProtobufSignature(u);e.sigMap?.sigPair?.push(l)}}return this._signerPublicKeys.add(e),this._publicKeys.push(t),this._transactionSigners.push(null),this}removeSignature(t){this.isFrozen()||this.freeze();const n=t.toBytesRaw(),s=u(n);if(!this._signerPublicKeys.has(s))throw new Error("The public key has not signed this transaction");const i=[];for(const t of this._signedTransactions.list){const n=this._removeSignaturesFromTransaction(t,s);i.push(...n)}return this._signerPublicKeys.delete(s),this._publicKeys=this._publicKeys.filter((n=>!n.equals(t))),this._transactionSigners.pop(),i}removeAllSignatures(){this.isFrozen()||this.freeze();const t=this._collectSignaturesByPublicKey();for(const t of this._signedTransactions.list)t.sigMap&&t.sigMap.sigPair&&(t.sigMap.sigPair=[]);return this._signerPublicKeys.clear(),this._publicKeys=[],this._transactionSigners=[],t}getSignatures(){return this._requireFrozen(),this._requireNotSignOnDemand(),this._buildAllTransactions(),this._transactionIds.setLocked(),this._nodeAccountIds.setLocked(),e._fromTransaction(this)}async getSignaturesAsync(){return this._transactionIds.setLocked(),this._nodeAccountIds.setLocked(),await this._buildAllTransactionsAsync(),this._transactions.setLocked(),this._signedTransactions.setLocked(),e._fromTransaction(this)}_setTransactionId(){if(null==this._operatorAccountId&&this._transactionIds.isEmpty)throw new Error("`transactionId` must be set or `client` must be provided with `freezeWith`")}_setNodeAccountIds(t){if(this._nodeAccountIds.isEmpty){if(null==t)throw new Error("`nodeAccountId` must be set or `client` must be provided with `freezeWith`");this._nodeAccountIds.setList(t._network.getNodeAccountIdsForExecute())}}_buildSignedTransactions(){this._signedTransactions.locked||this._signedTransactions.setList(this._nodeAccountIds.list.map((t=>this._makeSignedTransaction(t))))}_buildIncompleteTransactions(){0==this._nodeAccountIds.length?this._transactions.setList([this._makeSignedTransaction(null)]):this._transactions.setList(this._nodeAccountIds.list.map((t=>this._makeSignedTransaction(t))))}freeze(){return this.freezeWith(null)}_freezeWithAccountId(t){null==this._operatorAccountId&&(this._operatorAccountId=t)}freezeWith(t){if(this._signOnDemand=null!=t&&t.signOnDemand,this._operator=null!=t?t._operator:null,this._freezeWithAccountId(null!=t?t.operatorAccountId:null),this._maxTransactionFee=null==this._maxTransactionFee?null!=t&&null!=t.defaultMaxTransactionFee?t.defaultMaxTransactionFee:this._defaultMaxTransactionFee:this._maxTransactionFee,this._regenerateTransactionId=null!=t&&null==this._regenerateTransactionId?t.defaultRegenerateTransactionId:this._regenerateTransactionId,this._setNodeAccountIds(t),this._setTransactionId(),null!=t)for(const n of this._transactionIds.list)null!=n.accountId&&n.accountId.validateChecksum(t);return this._buildNewTransactionIdList(),this._signOnDemand||this._buildSignedTransactions(),this}async signWithSigner(t){return await t.signTransaction(this),this}async freezeWithSigner(t){return await t.populateTransaction(this),this.freeze(),this}toBytes(){return this._requireNotSignOnDemand(),this._isFrozen()?(this._transactionIds.setLocked(),this._nodeAccountIds.setLocked(),this._buildAllTransactions()):this._buildIncompleteTransactions(),d.proto.TransactionList.encode({transactionList:this._transactions.list}).finish()}async toBytesAsync(){return this._transactionIds.setLocked(),this._nodeAccountIds.setLocked(),await this._buildAllTransactionsAsync(),this._transactions.setLocked(),this._signedTransactions.setLocked(),d.proto.TransactionList.encode({transactionList:this._transactions.list}).finish()}async getTransactionHash(){return this._requireFrozen(),this._transactionIds.setLocked(),this._nodeAccountIds.setLocked(),await this._buildAllTransactionsAsync(),this._transactions.setLocked(),this._signedTransactions.setLocked(),h(this._transactions.get(0).signedTransactionBytes)}async getTransactionHashPerNode(){return this._requireFrozen(),this._transactionIds.setLocked(),this._nodeAccountIds.setLocked(),await this._buildAllTransactionsAsync(),await i._fromTransaction(this)}isFrozen(){return this._signedTransactions.length>0}_getTransactionId(){const t=this.transactionId;if(null==t)throw new Error("transaction must have been frozen before getting the transaction ID, try calling `freeze`");return t}_validateChecksums(t){}async _beforeExecute(t){this.transactionNodeIds=Object.values(t.network).map((t=>t.toString())),this._logger&&this._logger.info(`Network used: ${t._network.networkName}`),this._isFrozen()||this.freezeWith(t),t.isAutoValidateChecksumsEnabled()&&this._validateChecksums(t),null!=this._operator&&null!=this._operator||(this._operator=null!=t?t._operator:null),null!=this._operatorAccountId&&null!=this._operatorAccountId||(this._operatorAccountId=null!=t&&null!=t._operator?t._operator.accountId:null),null!=this._operator&&await this.signWith(this._operator.publicKey,this._operator.transactionSigner)}async _makeRequestAsync(){const t=this._transactionIds.index*this._nodeAccountIds.length+this._nodeAccountIds.index;return this._signOnDemand?await this._buildTransactionAsync():(this._buildTransaction(t),this._transactions.get(t))}async _signTransaction(){const t=this._makeSignedTransaction(this._nodeAccountIds.next),n=t.bodyBytes;for(let s=0;s<this._publicKeys.length;s++){const i=this._publicKeys[s],e=this._transactionSigners[s];if(null==e)continue;const o=await e(n);null==t.sigMap&&(t.sigMap={}),null==t.sigMap.sigPair&&(t.sigMap.sigPair=[]),t.sigMap.sigPair.push(i._toProtobufSignature(o))}return t}_buildNewTransactionIdList(){if(this._transactionIds.locked||null==this._operatorAccountId)return;const t=s.withValidStart(this._operatorAccountId,p.generate());this._transactionIds.set(this._transactionIds.index,t)}_buildAllTransactions(){for(let t=0;t<this._signedTransactions.length;t++)this._buildTransaction(t)}async _buildAllTransactionsAsync(){if(this._signOnDemand){if(this._buildSignedTransactions(),!this._transactions.locked)for(let t=0;t<this._signedTransactions.length;t++)this._transactions.push(await this._buildTransactionAsync())}else this._buildAllTransactions()}_buildTransaction(t){if(this._transactions.length<t)for(let n=this._transactions.length;n<t;n++)this._transactions.push(null);null!=this._transactions.list[t]&&this._transactions.set(t,{signedTransactionBytes:d.proto.SignedTransaction.encode(this._signedTransactions.get(t)).finish()}),this._transactions.setIfAbsent(t,(()=>({signedTransactionBytes:d.proto.SignedTransaction.encode(this._signedTransactions.get(t)).finish()})))}async _buildTransactionAsync(){return{signedTransactionBytes:d.proto.SignedTransaction.encode(await this._signTransaction()).finish()}}_shouldRetry(t,n){const{nodeTransactionPrecheckCode:s}=n,i=a._fromCode(null!=s?s:d.proto.ResponseCodeEnum.OK);switch(this._logger&&(this._logger.debug(`[${this._getLogId()}] received status ${i.toString()}`),this._logger.info(`SDK Transaction Status Response: ${i.toString()}`)),i){case a.Busy:case a.Unknown:case a.PlatformTransactionNotCreated:case a.PlatformNotActive:return[i,r.Retry];case a.Ok:return[i,r.Finished];case a.TransactionExpired:return this._transactionIds.locked||null!=this._regenerateTransactionId&&!this._regenerateTransactionId?[i,r.Error]:(this._buildNewTransactionIdList(),[i,r.Retry]);default:return[i,r.Error]}}_mapStatusError(t,n,s){const{nodeTransactionPrecheckCode:i}=n,e=a._fromCode(null!=i?i:d.proto.ResponseCodeEnum.OK);return this._logger&&this._logger.info(`Transaction Error Info: ${e.toString()}, ${this.transactionId.toString()}`),new l({nodeId:s,status:e,transactionId:this._getTransactionId(),contractFunctionResult:null})}async _mapResponse(t,s,i){const e=await h(i.signedTransactionBytes),o=this._getTransactionId();return this._transactionIds.advance(),this._logger&&this._logger.info(`Transaction Info: ${JSON.stringify(new n({nodeId:s,transactionHash:e,transactionId:o}).toJSON())}`),new n({nodeId:s,transactionHash:e,transactionId:o})}_makeSignedTransaction(t){const n=this._makeTransactionBody(t);this._logger&&this._logger.info(`Transaction Body: ${JSON.stringify(n)}`);return{sigMap:{sigPair:[]},bodyBytes:d.proto.TransactionBody.encode(n).finish()}}_makeTransactionBody(t){return{[this._getTransactionDataCase()]:this._makeTransactionData(),transactionFee:null!=this._maxTransactionFee?this._maxTransactionFee.toTinybars():null,memo:this._transactionMemo,transactionID:null!=this._transactionIds.current?this._transactionIds.current._toProtobuf():null,nodeAccountID:null!=t?t._toProtobuf():null,transactionValidDuration:{seconds:c.fromNumber(this._transactionValidDuration)},maxCustomFees:null!=this._customFeeLimits?this._customFeeLimits.map((t=>t._toProtobuf())):null}}_getTransactionDataCase(){throw new Error("not implemented")}_getScheduledTransactionBody(){return{memo:this.transactionMemo,transactionFee:null==this._maxTransactionFee?this._defaultMaxTransactionFee.toTinybars():this._maxTransactionFee.toTinybars(),[this._getTransactionDataCase()]:this._makeTransactionData()}}_makeTransactionData(){throw new Error("not implemented")}_isFrozen(){return this._signOnDemand||this._signedTransactions.length>0}_requireNotFrozen(){if(this._isFrozen())throw new Error("transaction is immutable; it has at least one signature or has been explicitly frozen")}_requireNotSignOnDemand(){if(this._signOnDemand)throw new Error("Please use `toBytesAsync()` if `signOnDemand` is enabled")}_requireFrozen(){if(!this._isFrozen())throw new Error("transaction must have been frozen before calculating the hash will be stable, try calling `freeze`")}_requireOneNodeAccountId(){if(1!=this._nodeAccountIds.length)throw"transaction did not have exactly one node ID set"}_requestToBytes(t){return d.proto.Transaction.encode(t).finish()}_responseToBytes(t){return d.proto.TransactionResponse.encode(t).finish()}_removeSignaturesFromTransaction(t,n){const s=[];return t.sigMap&&t.sigMap.sigPair?(t.sigMap.sigPair=t.sigMap.sigPair.filter((t=>{const i=this._shouldRemoveSignature(t,n),e=t.ed25519??t.ECDSASecp256k1;return i&&e&&s.push(e),!i})),s):[]}_shouldRemoveSignature=(t,n)=>u(t?.pubKeyPrefix||new Uint8Array)===n;_collectSignaturesByPublicKey(){const t=new Map,n={};for(const s of this._signedTransactions.list){if(!s.sigMap||!s.sigMap.sigPair)return new Map;for(const i of s.sigMap.sigPair){const s=i.ed25519??i.ECDSASecp256k1;if(!s||!i.pubKeyPrefix)return new Map;const e=u(i.pubKeyPrefix);let o=n[e];o||(o=g.fromString(e),n[e]=o),t.has(o)||t.set(o,[]);const r=t.get(o);r&&r.push(s)}}return t}}const A=[];export{b as CHUNK_SIZE,y as DEFAULT_AUTO_RENEW_PERIOD,I as DEFAULT_RECORD_THRESHOLD,A as SCHEDULE_CREATE_TRANSACTION,w as TRANSACTION_REGISTRY,S as default};
//# sourceMappingURL=Transaction.js.map
