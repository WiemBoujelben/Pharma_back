{"version":3,"file":"Transaction.js","sources":["../../src/transaction/Transaction.js"],"sourcesContent":["// SPDX-License-Identifier: Apache-2.0\n\nimport Hbar from \"../Hbar.js\";\nimport TransactionResponse from \"./TransactionResponse.js\";\nimport TransactionId from \"./TransactionId.js\";\nimport TransactionHashMap from \"./TransactionHashMap.js\";\nimport SignatureMap from \"./SignatureMap.js\";\nimport Executable, { ExecutionState } from \"../Executable.js\";\nimport Status from \"../Status.js\";\nimport Long from \"long\";\nimport * as sha384 from \"../cryptography/sha384.js\";\nimport * as hex from \"../encoding/hex.js\";\nimport * as HieroProto from \"@hashgraph/proto\";\nimport PrecheckStatusError from \"../PrecheckStatusError.js\";\nimport AccountId from \"../account/AccountId.js\";\nimport PublicKey from \"../PublicKey.js\";\nimport List from \"./List.js\";\nimport Timestamp from \"../Timestamp.js\";\nimport * as util from \"../util.js\";\nimport CustomFeeLimit from \"./CustomFeeLimit.js\";\n\n/**\n * @typedef {import(\"bignumber.js\").default} BigNumber\n */\n\n/**\n * @typedef {import(\"../schedule/ScheduleCreateTransaction.js\").default} ScheduleCreateTransaction\n * @typedef {import(\"../PrivateKey.js\").default} PrivateKey\n * @typedef {import(\"../channel/Channel.js\").default} Channel\n * @typedef {import(\"../client/Client.js\").default<*, *>} Client\n * @typedef {import(\"../Signer.js\").Signer} Signer\n */\n\n// 90 days (in seconds)\nexport const DEFAULT_AUTO_RENEW_PERIOD = Long.fromValue(7776000);\n\n// maximum value of i64 (so there is never a record generated)\nexport const DEFAULT_RECORD_THRESHOLD = Hbar.fromTinybars(\n    Long.fromString(\"9223372036854775807\"),\n);\n\n// 120 seconds\nconst DEFAULT_TRANSACTION_VALID_DURATION = 120;\n\n// The default message chunk size in bytes when splitting a given message.\n// This value can be overriden using `setChunkSize` when preparing to submit a messsage via `TopicMessageSubmitTransaction`.\nexport const CHUNK_SIZE = 1024;\n\n/**\n * @type {Map<NonNullable<HieroProto.proto.TransactionBody[\"data\"]>, (transactions: HieroProto.proto.ITransaction[], signedTransactions: HieroProto.proto.ISignedTransaction[], transactionIds: TransactionId[], nodeIds: AccountId[], bodies: HieroProto.proto.TransactionBody[]) => Transaction>}\n */\nexport const TRANSACTION_REGISTRY = new Map();\n\n/**\n * Base class for all transactions that may be submitted to Hedera.\n *\n * @abstract\n * @augments {Executable<HieroProto.proto.ITransaction, HieroProto.proto.ITransactionResponse, TransactionResponse>}\n */\nexport default class Transaction extends Executable {\n    // A SDK transaction is composed of multiple, raw protobuf transactions.\n    // These should be functionally identical, with the exception of pointing to\n    // different nodes.\n\n    // When retrying a transaction after a network error or retry-able\n    // status response, we try a different transaction and thus a different node.\n\n    constructor() {\n        super();\n\n        /**\n         * List of proto transactions that have been built from this SDK\n         * transaction.\n         *\n         * This is a 2-D array built into one, meaning to\n         * get to the next row you'd index into this array `row * rowLength + column`\n         * where `rowLength` is `nodeAccountIds.length`\n         *\n         * @internal\n         * @type {List<HieroProto.proto.ITransaction | null>}\n         */\n        this._transactions = new List();\n\n        /**\n         * List of proto transactions that have been built from this SDK\n         * transaction.\n         *\n         * This is a 2-D array built into one, meaning to\n         * get to the next row you'd index into this array `row * rowLength + column`\n         * where `rowLength` is `nodeAccountIds.length`\n         *\n         * @internal\n         * @type {List<HieroProto.proto.ISignedTransaction>}\n         */\n        this._signedTransactions = new List();\n\n        /**\n         * Set of public keys (as string) who have signed this transaction so\n         * we do not allow them to sign it again.\n         *\n         * @internal\n         * @type {Set<string>}\n         */\n        this._signerPublicKeys = new Set();\n\n        /**\n         * The transaction valid duration\n         *\n         * @private\n         * @type {number}\n         */\n        this._transactionValidDuration = DEFAULT_TRANSACTION_VALID_DURATION;\n\n        /**\n         * The default max transaction fee for this particular transaction type.\n         * Most transactions use the default of 2 Hbars, but some requests such\n         * as `TokenCreateTransaction` need to use a different default value.\n         *\n         * @protected\n         * @type {Hbar}\n         */\n        this._defaultMaxTransactionFee = new Hbar(2);\n\n        /**\n         * The maximum custom fee that the user is willing to pay for the message. If left empty, the user is willing to pay any custom fee.\n         * If used with a transaction type that does not support custom fee limits, the transaction will fail.\n         * @type {CustomFeeLimit[]}\n         */\n        this._customFeeLimits = [];\n\n        /**\n         * The max transaction fee on the request. This field is what users are able\n         * to set, not the `defaultMaxTransactionFee`. The purpose of this field is\n         * to allow us to determine if the user set the field explicitly, or if we're\n         * using the default max transation fee for the request.\n         *\n         * @private\n         * @type {Hbar | null}\n         */\n        this._maxTransactionFee = null;\n\n        /**\n         * The transaction's memo\n         *\n         * @private\n         * @type {string}\n         */\n        this._transactionMemo = \"\";\n\n        /**\n         * The list of transaction IDs. This list will almost always be of length 1.\n         * The only time this list will be a different length is for chunked transactions.\n         * The only two chunked transactions supported right now are `FileAppendTransaction`\n         * and `TopicMessageSubmitTransaction`\n         *\n         * @protected\n         * @type {List<TransactionId>}\n         */\n        this._transactionIds = new List();\n\n        /**\n         * A list of public keys that will be added to the requests signatures\n         *\n         * @private\n         * @type {PublicKey[]}\n         */\n        this._publicKeys = [];\n\n        /**\n         * The list of signing function 1-1 with `_publicKeys` which sign the request.\n         * The reason this list allows `null` is because if we go from bytes into\n         * a transaction, then we know the public key, but we don't have the signing function.\n         *\n         * @private\n         * @type {(((message: Uint8Array) => Promise<Uint8Array>) | null)[]}\n         */\n        this._transactionSigners = [];\n\n        /**\n         * Determine if we should regenerate transaction IDs when we receive `TRANSACITON_EXPIRED`\n         *\n         * @private\n         * @type {?boolean}\n         */\n        this._regenerateTransactionId = null;\n    }\n\n    /**\n     * Deserialize a transaction from bytes. The bytes can either be a `proto.Transaction` or\n     * `proto.TransactionList`.\n     *\n     * @param {Uint8Array} bytes\n     * @returns {Transaction}\n     */\n    static fromBytes(bytes) {\n        /** @type {HieroProto.proto.ISignedTransaction[]} */\n        const signedTransactions = [];\n\n        /** @type {TransactionId[]} */\n        const transactionIds = [];\n\n        /** @type {AccountId[]} */\n        const nodeIds = [];\n\n        /** @type {string[]} */\n        const transactionIdStrings = [];\n\n        /** @type {string[]} */\n        const nodeIdStrings = [];\n\n        /** @type {HieroProto.proto.TransactionBody[]} */\n        const bodies = [];\n\n        const list =\n            HieroProto.proto.TransactionList.decode(bytes).transactionList;\n\n        // If the list is of length 0, then teh bytes provided were not a\n        // `proto.TransactionList`\n        //\n        // FIXME: We should also check to make sure the bytes length is greater than\n        // 0 otherwise this check is wrong?\n        if (list.length === 0) {\n            const transaction = HieroProto.proto.Transaction.decode(bytes);\n\n            // We support `Transaction.signedTransactionBytes` and\n            // `Transaction.bodyBytes` + `Transaction.sigMap`. If the bytes represent the\n            // latter, convert them into `signedTransactionBytes`\n            if (transaction.signedTransactionBytes.length !== 0) {\n                list.push(transaction);\n            } else {\n                list.push({\n                    signedTransactionBytes:\n                        HieroProto.proto.SignedTransaction.encode({\n                            sigMap: transaction.sigMap,\n                            bodyBytes: transaction.bodyBytes,\n                        }).finish(),\n                });\n            }\n        }\n\n        // This loop is responsible for fill out the `signedTransactions`, `transactionIds`,\n        // `nodeIds`, and `bodies` variables.\n        for (const transaction of list) {\n            // The `bodyBytes` or `signedTransactionBytes` should not be null\n            if (\n                transaction.bodyBytes == null &&\n                transaction.signedTransactionBytes == null\n            ) {\n                throw new Error(\n                    \"bodyBytes and signedTransactionBytes are null\",\n                );\n            }\n\n            if (transaction.bodyBytes && transaction.bodyBytes.length != 0) {\n                // Decode a transaction\n                const body = HieroProto.proto.TransactionBody.decode(\n                    transaction.bodyBytes,\n                );\n\n                // Make sure the transaction ID within the body is set\n                if (body.transactionID != null) {\n                    const transactionId = TransactionId._fromProtobuf(\n                        /** @type {HieroProto.proto.ITransactionID} */ (\n                            body.transactionID\n                        ),\n                    );\n\n                    // If we haven't already seen this transaction ID in the list, add it\n                    if (\n                        !transactionIdStrings.includes(transactionId.toString())\n                    ) {\n                        transactionIds.push(transactionId);\n                        transactionIdStrings.push(transactionId.toString());\n                    }\n                }\n\n                // Make sure the node account ID within the body is set\n                if (body.nodeAccountID != null) {\n                    const nodeAccountId = AccountId._fromProtobuf(\n                        /** @type {HieroProto.proto.IAccountID} */ (\n                            body.nodeAccountID\n                        ),\n                    );\n\n                    // If we haven't already seen this node account ID in the list, add it\n                    if (!nodeIdStrings.includes(nodeAccountId.toString())) {\n                        nodeIds.push(nodeAccountId);\n                        nodeIdStrings.push(nodeAccountId.toString());\n                    }\n                }\n\n                // Make sure the body is set\n                if (body.data == null) {\n                    throw new Error(\n                        \"(BUG) body.data was not set in the protobuf\",\n                    );\n                }\n\n                bodies.push(body);\n            }\n\n            if (\n                transaction.signedTransactionBytes &&\n                transaction.signedTransactionBytes.length != 0\n            ) {\n                // Decode a signed transaction\n                const signedTransaction =\n                    HieroProto.proto.SignedTransaction.decode(\n                        transaction.signedTransactionBytes,\n                    );\n\n                signedTransactions.push(signedTransaction);\n\n                // Decode a transaction body\n                const body = HieroProto.proto.TransactionBody.decode(\n                    signedTransaction.bodyBytes,\n                );\n\n                // Make sure the transaction ID within the body is set\n                if (body.transactionID != null) {\n                    const transactionId = TransactionId._fromProtobuf(\n                        /** @type {HieroProto.proto.ITransactionID} */ (\n                            body.transactionID\n                        ),\n                    );\n\n                    // If we haven't already seen this transaction ID in the list, add it\n                    if (\n                        !transactionIdStrings.includes(transactionId.toString())\n                    ) {\n                        transactionIds.push(transactionId);\n                        transactionIdStrings.push(transactionId.toString());\n                    }\n                }\n\n                // Make sure the node account ID within the body is set\n                if (body.nodeAccountID != null) {\n                    const nodeAccountId = AccountId._fromProtobuf(\n                        /** @type {HieroProto.proto.IAccountID} */ (\n                            body.nodeAccountID\n                        ),\n                    );\n\n                    // If we haven't already seen this node account ID in the list, add it\n                    if (!nodeIdStrings.includes(nodeAccountId.toString())) {\n                        nodeIds.push(nodeAccountId);\n                        nodeIdStrings.push(nodeAccountId.toString());\n                    }\n                }\n\n                // Make sure the body is set\n                if (body.data == null) {\n                    throw new Error(\n                        \"(BUG) body.data was not set in the protobuf\",\n                    );\n                }\n\n                bodies.push(body);\n            }\n        }\n\n        // FIXME: We should have a length check before we access `0` since that would error\n        const body = bodies[0];\n\n        // We should have at least more than one body\n        if (body == null || body.data == null) {\n            throw new Error(\n                \"No transaction found in bytes or failed to decode TransactionBody\",\n            );\n        }\n\n        // Use the registry to call the right transaction's `fromProtobuf` method based\n        // on the `body.data` string\n        const fromProtobuf = TRANSACTION_REGISTRY.get(body.data); //NOSONAR\n\n        // If we forgot to update the registry we should error\n        if (fromProtobuf == null) {\n            throw new Error(\n                `(BUG) Transaction.fromBytes() not implemented for type ${body.data}`,\n            );\n        }\n\n        // That the specific transaction type from protobuf implementation and pass in all the\n        // information we've gathered.\n        return fromProtobuf(\n            list,\n            signedTransactions,\n            transactionIds,\n            nodeIds,\n            bodies,\n        );\n    }\n\n    /**\n     * Convert this transaction a `ScheduleCreateTransaction`\n     *\n     * @returns {ScheduleCreateTransaction}\n     */\n    schedule() {\n        this._requireNotFrozen();\n\n        if (SCHEDULE_CREATE_TRANSACTION.length != 1) {\n            throw new Error(\n                \"ScheduleCreateTransaction has not been loaded yet\",\n            );\n        }\n\n        return SCHEDULE_CREATE_TRANSACTION[0]()._setScheduledTransaction(this);\n    }\n\n    /**\n     * This method is called by each `*Transaction._fromProtobuf()` method. It does\n     * all the finalization before the user gets hold of a complete `Transaction`\n     *\n     * @template {Transaction} TransactionT\n     * @param {TransactionT} transaction\n     * @param {HieroProto.proto.ITransaction[]} transactions\n     * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions\n     * @param {TransactionId[]} transactionIds\n     * @param {AccountId[]} nodeIds\n     * @param {HieroProto.proto.ITransactionBody[]} bodies\n     * @returns {TransactionT}\n     */\n    static _fromProtobufTransactions(\n        transaction,\n        transactions,\n        signedTransactions,\n        transactionIds,\n        nodeIds,\n        bodies,\n    ) {\n        const body = bodies[0];\n\n        // \"row\" of the 2-D `bodies` array has all the same contents except for `nodeAccountID`\n        for (let i = 0; i < transactionIds.length; i++) {\n            for (let j = 0; j < nodeIds.length - 1; j++) {\n                if (\n                    !util.compare(\n                        bodies[i * nodeIds.length + j],\n                        bodies[i * nodeIds.length + j + 1],\n                        // eslint-disable-next-line ie11/no-collection-args\n                        new Set([\"nodeAccountID\"]),\n                    )\n                ) {\n                    throw new Error(\"failed to validate transaction bodies\");\n                }\n            }\n        }\n\n        // Remove node account IDs of 0\n        // _IIRC_ this was initial due to some funny behavior with `ScheduleCreateTransaction`\n        // We may be able to remove this.\n        const zero = new AccountId(0);\n        for (let i = 0; i < nodeIds.length; i++) {\n            if (nodeIds[i].equals(zero)) {\n                nodeIds.splice(i--, 1);\n            }\n        }\n\n        // Set the transactions accordingly, but don't lock the list because transactions can\n        // be regenerated if more signatures are added\n        transaction._transactions.setList(transactions);\n\n        // Set the signed transactions accordingly. Although, they\n        // can be manipulated if for instance more signatures are added\n        transaction._signedTransactions.setList(signedTransactions);\n\n        // Set the transaction IDs accordingly\n        transaction._transactionIds.setList(transactionIds);\n\n        // Set the node account IDs accordingly\n        transaction._nodeAccountIds.setList(nodeIds);\n\n        // Make sure to update the rest of the fields\n        transaction._transactionValidDuration =\n            body.transactionValidDuration != null &&\n            body.transactionValidDuration.seconds != null\n                ? Long.fromValue(body.transactionValidDuration.seconds).toInt()\n                : DEFAULT_TRANSACTION_VALID_DURATION;\n        transaction._maxTransactionFee =\n            body.transactionFee != null &&\n            body.transactionFee > new Long(0, 0, true)\n                ? Hbar.fromTinybars(body.transactionFee)\n                : null;\n        transaction._customFeeLimits =\n            body.maxCustomFees != null\n                ? body.maxCustomFees?.map((fee) =>\n                      CustomFeeLimit._fromProtobuf(fee),\n                  )\n                : [];\n        transaction._transactionMemo = body.memo != null ? body.memo : \"\";\n\n        // Loop over a single row of `signedTransactions` and add all the public\n        // keys to the `signerPublicKeys` set, and `publicKeys` list with\n        // `null` in the `transactionSigners` at the same index.\n        for (let i = 0; i < nodeIds.length; i++) {\n            const tx = signedTransactions[i] || transactions[i];\n            if (tx.sigMap != null && tx.sigMap.sigPair != null) {\n                for (const sigPair of tx.sigMap.sigPair) {\n                    transaction._signerPublicKeys.add(\n                        hex.encode(\n                            /** @type {Uint8Array} */ (sigPair.pubKeyPrefix),\n                        ),\n                    );\n\n                    transaction._publicKeys.push(\n                        PublicKey.fromBytes(\n                            /** @type {Uint8Array} */ (sigPair.pubKeyPrefix),\n                        ),\n                    );\n                    transaction._transactionSigners.push(null);\n                }\n            }\n        }\n\n        return transaction;\n    }\n\n    /**\n     * Set the node account IDs\n     *\n     * @override\n     * @param {AccountId[]} nodeIds\n     * @returns {this}\n     */\n    setNodeAccountIds(nodeIds) {\n        // The reason we overwrite this method is simply because we need to call `requireNotFrozen()`\n        // Now that I think of it, we could just add an abstract method `setterPrerequiest()` which\n        // by default does nothing, and `Executable` can call. Then we'd only need to overwrite that\n        // method once.\n        this._requireNotFrozen();\n        super.setNodeAccountIds(nodeIds);\n        return this;\n    }\n\n    /**\n     * Get the transaction valid duration\n     *\n     * @returns {number}\n     */\n    get transactionValidDuration() {\n        return this._transactionValidDuration;\n    }\n\n    /**\n     * Sets the duration (in seconds) that this transaction is valid for.\n     *\n     * This is defaulted to 120 seconds (from the time its executed).\n     *\n     * @param {number} validDuration\n     * @returns {this}\n     */\n    setTransactionValidDuration(validDuration) {\n        this._requireNotFrozen();\n        this._transactionValidDuration = validDuration;\n\n        return this;\n    }\n\n    /**\n     * Get the max transaction fee\n     *\n     * @returns {?Hbar}\n     */\n    get maxTransactionFee() {\n        return this._maxTransactionFee;\n    }\n\n    /**\n     * Set the maximum transaction fee the operator (paying account)\n     * is willing to pay.\n     *\n     * @param {number | string | Long | BigNumber | Hbar} maxTransactionFee\n     * @returns {this}\n     */\n    setMaxTransactionFee(maxTransactionFee) {\n        this._requireNotFrozen();\n        this._maxTransactionFee =\n            maxTransactionFee instanceof Hbar\n                ? maxTransactionFee\n                : new Hbar(maxTransactionFee);\n\n        return this;\n    }\n\n    /**\n     * Is transaction ID regeneration enabled\n     *\n     * @returns {?boolean}\n     */\n    get regenerateTransactionId() {\n        return this._regenerateTransactionId;\n    }\n\n    /**\n     * Set the maximum transaction fee the operator (paying account)\n     * is willing to pay.\n     *\n     * @param {boolean} regenerateTransactionId\n     * @returns {this}\n     */\n    setRegenerateTransactionId(regenerateTransactionId) {\n        this._requireNotFrozen();\n        this._regenerateTransactionId = regenerateTransactionId;\n\n        return this;\n    }\n\n    /**\n     * Get the transaction memo\n     *\n     * @returns {string}\n     */\n    get transactionMemo() {\n        return this._transactionMemo;\n    }\n\n    /**\n     * Set a note or description to be recorded in the transaction\n     * record (maximum length of 100 bytes).\n     *\n     * @param {string} transactionMemo\n     * @returns {this}\n     */\n    setTransactionMemo(transactionMemo) {\n        this._requireNotFrozen();\n        this._transactionMemo = transactionMemo;\n\n        return this;\n    }\n\n    /**\n     * Get the curent transaction ID\n     *\n     * @returns {?TransactionId}\n     */\n    get transactionId() {\n        if (this._transactionIds.isEmpty) {\n            return null;\n        }\n\n        // If a user calls `.transactionId` that means we need to use that transaction ID\n        // and **not** regenerate it. To do this, we simply lock the transaction ID list.\n        //\n        // This may be a little conffusing since a user can enable transaction ID regenration\n        // explicity, but if they call `.transactionId` then we will not regenerate transaction\n        // IDs.\n        this._transactionIds.setLocked();\n\n        return this._transactionIds.current;\n    }\n\n    /**\n     * Set the ID for this transaction.\n     *\n     * The transaction ID includes the operator's account ( the account paying the transaction\n     * fee). If two transactions have the same transaction ID, they won't both have an effect. One\n     * will complete normally and the other will fail with a duplicate transaction status.\n     *\n     * Normally, you should not use this method. Just before a transaction is executed, a\n     * transaction ID will be generated from the operator on the client.\n     *\n     * @param {TransactionId} transactionId\n     * @returns {this}\n     */\n    setTransactionId(transactionId) {\n        this._requireNotFrozen();\n        this._transactionIds.setList([transactionId]).setLocked();\n\n        return this;\n    }\n\n    /**\n     * How many chunk sizes are expected\n     * @abstract\n     * @internal\n     * @returns {number}\n     */\n    getRequiredChunks() {\n        return 1;\n    }\n\n    /**\n     * Sign the transaction with the private key\n     * **NOTE**: This is a thin wrapper around `.signWith()`\n     *\n     * @param {PrivateKey} privateKey\n     * @returns {Promise<this>}\n     */\n    sign(privateKey) {\n        return this.signWith(privateKey.publicKey, (message) =>\n            Promise.resolve(privateKey.sign(message)),\n        );\n    }\n\n    /**\n     * Sign the transaction with the public key and signer function\n     *\n     * If sign on demand is enabled no signing will be done immediately, instead\n     * the private key signing function and public key are saved to be used when\n     * a user calls an exit condition method (not sure what a better name for this is)\n     * such as `toBytes[Async]()`, `getTransactionHash[PerNode]()` or `execute()`.\n     *\n     * @param {PublicKey} publicKey\n     * @param {(message: Uint8Array) => Promise<Uint8Array>} transactionSigner\n     * @returns {Promise<this>}\n     */\n    async signWith(publicKey, transactionSigner) {\n        // If signing on demand is disabled, we need to make sure\n        // the request is frozen\n        if (!this._signOnDemand) {\n            this._requireFrozen();\n        }\n        const publicKeyData = publicKey.toBytesRaw();\n\n        // note: this omits the DER prefix on purpose because Hedera doesn't\n        // support that in the protobuf. this means that we would fail\n        // to re-inflate [this._signerPublicKeys] during [fromBytes] if we used DER\n        // prefixes here\n        const publicKeyHex = hex.encode(publicKeyData);\n\n        if (this._signerPublicKeys.has(publicKeyHex)) {\n            // this public key has already signed this transaction\n            return this;\n        }\n\n        // If we add a new signer, then we need to re-create all transactions\n        this._transactions.clear();\n\n        // Save the current public key so we don't attempt to sign twice\n        this._signerPublicKeys.add(publicKeyHex);\n\n        // If signing on demand is enabled we will save the public key and signer and return\n        if (this._signOnDemand) {\n            this._publicKeys.push(publicKey);\n            this._transactionSigners.push(transactionSigner);\n\n            return this;\n        }\n\n        // If we get here, signing on demand is disabled, this means the transaction\n        // is frozen and we need to sign all the transactions immediately. If we're\n        // signing all the transactions immediately, we need to lock the node account IDs\n        // and transaction IDs.\n        // Now that I think of it, this code should likely exist in `freezeWith()`?\n        this._transactionIds.setLocked();\n        this._nodeAccountIds.setLocked();\n\n        // Sign each signed transatcion\n        for (const signedTransaction of this._signedTransactions.list) {\n            const bodyBytes = /** @type {Uint8Array} */ (\n                signedTransaction.bodyBytes\n            );\n            const signature = await transactionSigner(bodyBytes);\n\n            if (signedTransaction.sigMap == null) {\n                signedTransaction.sigMap = {};\n            }\n\n            if (signedTransaction.sigMap.sigPair == null) {\n                signedTransaction.sigMap.sigPair = [];\n            }\n\n            signedTransaction.sigMap.sigPair.push(\n                publicKey._toProtobufSignature(signature),\n            );\n        }\n\n        return this;\n    }\n\n    /**\n     * Sign the transaction with the client operator. This is a thin wrapper\n     * around `.signWith()`\n     *\n     * **NOTE**: If client does not have an operator set, this method will throw\n     *\n     * @param {import(\"../client/Client.js\").default<Channel, *>} client\n     * @returns {Promise<this>}\n     */\n    signWithOperator(client) {\n        const operator = client._operator;\n\n        if (operator == null) {\n            throw new Error(\n                \"`client` must have an operator to sign with the operator\",\n            );\n        }\n\n        if (!this._isFrozen()) {\n            this.freezeWith(client);\n        }\n\n        return this.signWith(operator.publicKey, operator.transactionSigner);\n    }\n\n    /**\n     * Add a signature explicitly\n     *\n     * @param {PublicKey} publicKey\n     * @param {SignatureMap} signatureMap\n     * @returns {this}\n     */\n    addSignature(publicKey, signatureMap) {\n        // If the transaction isn't frozen, freeze it.\n        if (!this.isFrozen()) {\n            this.freeze();\n        }\n\n        const publicKeyData = publicKey.toBytesRaw();\n        const publicKeyHex = hex.encode(publicKeyData);\n\n        if (this._signerPublicKeys.has(publicKeyHex)) {\n            // this public key has already signed this transaction\n            return this;\n        }\n\n        // If we add a new signer, then we need to re-create all transactions\n        this._transactions.clear();\n\n        // Locking the transaction IDs and node account IDs is necessary for consistency\n        // between before and after execution\n        this._transactionIds.setLocked();\n        this._nodeAccountIds.setLocked();\n        this._signedTransactions.setLocked();\n\n        // Add the signature to the signed transaction list\n        for (let index = 0; index < this._signedTransactions.length; index++) {\n            const signedTransaction = this._signedTransactions.get(index);\n            if (signedTransaction.sigMap == null) {\n                signedTransaction.sigMap = {};\n            }\n\n            if (signedTransaction.sigMap.sigPair == null) {\n                signedTransaction.sigMap.sigPair = [];\n            }\n\n            if (signedTransaction.bodyBytes) {\n                const { transactionID, nodeAccountID } =\n                    HieroProto.proto.TransactionBody.decode(\n                        signedTransaction.bodyBytes,\n                    );\n\n                if (!transactionID || !nodeAccountID) {\n                    throw new Error(\n                        \"Transaction ID or Node Account ID not found in the signed transaction\",\n                    );\n                }\n\n                const transactionId =\n                    TransactionId._fromProtobuf(transactionID);\n                const nodeAccountId = AccountId._fromProtobuf(nodeAccountID);\n\n                const nodeSignatures = signatureMap.get(nodeAccountId);\n                const transactionSignatures =\n                    nodeSignatures?.get(transactionId);\n                const signature = transactionSignatures?.get(publicKey);\n\n                if (!signature) {\n                    throw new Error(\n                        \"Signature not found for the transaction and public key\",\n                    );\n                }\n                const sigPair = publicKey._toProtobufSignature(signature);\n                signedTransaction.sigMap?.sigPair?.push(sigPair);\n            }\n        }\n\n        this._signerPublicKeys.add(publicKeyHex);\n        this._publicKeys.push(publicKey);\n        this._transactionSigners.push(null);\n\n        return this;\n    }\n\n    /**\n     * This method removes all signatures from the transaction based on the public key provided.\n     *\n     * @param {PublicKey} publicKey - The public key associated with the signature to remove.\n     * @returns {Uint8Array[]} The removed signatures.\n     */\n    removeSignature(publicKey) {\n        if (!this.isFrozen()) {\n            this.freeze();\n        }\n\n        const publicKeyData = publicKey.toBytesRaw();\n        const publicKeyHex = hex.encode(publicKeyData);\n\n        if (!this._signerPublicKeys.has(publicKeyHex)) {\n            throw new Error(\"The public key has not signed this transaction\");\n        }\n\n        /** @type {Uint8Array[]} */\n        const removedSignatures = [];\n\n        // Iterate over the signed transactions and remove matching signatures\n        for (const transaction of this._signedTransactions.list) {\n            const removedSignaturesFromTransaction =\n                this._removeSignaturesFromTransaction(\n                    transaction,\n                    publicKeyHex,\n                );\n\n            removedSignatures.push(...removedSignaturesFromTransaction);\n        }\n\n        // Remove the public key from internal tracking if no signatures remain\n        this._signerPublicKeys.delete(publicKeyHex);\n        this._publicKeys = this._publicKeys.filter(\n            (key) => !key.equals(publicKey),\n        );\n\n        // Update transaction signers array\n        this._transactionSigners.pop();\n\n        return removedSignatures;\n    }\n\n    /**\n     * This method clears all signatures from the transaction and returns them in a specific format.\n     *\n     * It will call collectSignatures to get the removed signatures, then clear all signatures\n     * from the internal tracking.\n     *\n     * @returns { Map<PublicKey, Uint8Array[] | Uint8Array> } The removed signatures in the specified format.\n     */\n    removeAllSignatures() {\n        if (!this.isFrozen()) {\n            this.freeze();\n        }\n\n        const removedSignatures = this._collectSignaturesByPublicKey();\n\n        // Iterate over the signed transactions and clear all signatures\n        for (const transaction of this._signedTransactions.list) {\n            if (transaction.sigMap && transaction.sigMap.sigPair) {\n                // Clear all signature pairs from the transaction's signature map\n                transaction.sigMap.sigPair = [];\n            }\n        }\n\n        // Clear the internal tracking of signer public keys and other relevant arrays\n        this._signerPublicKeys.clear();\n        this._publicKeys = [];\n        this._transactionSigners = [];\n\n        return removedSignatures;\n    }\n\n    /**\n     * Get the current signatures on the request\n     *\n     * **NOTE**: Does NOT support sign on demand\n     *\n     * @returns {SignatureMap}\n     */\n    getSignatures() {\n        // If a user is attempting to get signatures for a transaction, then the\n        // transaction must be frozen.\n        this._requireFrozen();\n\n        // Sign on demand must be disabled because this is the non-async version and\n        // signing requires awaiting callbacks.\n        this._requireNotSignOnDemand();\n\n        // Build all the transactions\n        this._buildAllTransactions();\n\n        // Lock transaction IDs, and node account IDs\n        this._transactionIds.setLocked();\n        this._nodeAccountIds.setLocked();\n\n        // Construct a signature map from this transaction\n        return SignatureMap._fromTransaction(this);\n    }\n\n    /**\n     * Get the current signatures on the request\n     *\n     * **NOTE**: Supports sign on demand\n     *\n     * @returns {Promise<SignatureMap>}\n     */\n    async getSignaturesAsync() {\n        // If sign on demand is enabled, we don't need to care about being frozen\n        // since we can just regenerate and resign later if some field of the transaction\n        // changes.\n\n        // Locking the transaction IDs and node account IDs is necessary for consistency\n        // between before and after execution\n        this._transactionIds.setLocked();\n        this._nodeAccountIds.setLocked();\n\n        // Build all transactions, and sign them\n        await this._buildAllTransactionsAsync();\n\n        // Lock transaction IDs, and node account IDs\n        this._transactions.setLocked();\n        this._signedTransactions.setLocked();\n\n        // Construct a signature map from this transaction\n        return SignatureMap._fromTransaction(this);\n    }\n\n    /**\n     * Not sure why this is called `setTransactionId()` when it doesn't set anything...\n     * FIXME: Remove this?\n     */\n    _setTransactionId() {\n        if (this._operatorAccountId == null && this._transactionIds.isEmpty) {\n            throw new Error(\n                \"`transactionId` must be set or `client` must be provided with `freezeWith`\",\n            );\n        }\n    }\n\n    /**\n     * Set the node account IDs using the client\n     *\n     * @param {?import(\"../client/Client.js\").default<Channel, *>} client\n     */\n    _setNodeAccountIds(client) {\n        if (!this._nodeAccountIds.isEmpty) {\n            return;\n        }\n\n        if (client == null) {\n            throw new Error(\n                \"`nodeAccountId` must be set or `client` must be provided with `freezeWith`\",\n            );\n        }\n\n        this._nodeAccountIds.setList(\n            client._network.getNodeAccountIdsForExecute(),\n        );\n    }\n\n    /**\n     * Build all the signed transactions from the node account IDs\n     *\n     * @private\n     */\n    _buildSignedTransactions() {\n        if (this._signedTransactions.locked) {\n            return;\n        }\n\n        this._signedTransactions.setList(\n            this._nodeAccountIds.list.map((nodeId) =>\n                this._makeSignedTransaction(nodeId),\n            ),\n        );\n    }\n\n    /**\n     * Build all the signed transactions from the node account IDs\n     *\n     * @internal\n     */\n    _buildIncompleteTransactions() {\n        if (this._nodeAccountIds.length == 0) {\n            this._transactions.setList([this._makeSignedTransaction(null)]);\n        } else {\n            // In case the node account ids are set\n            this._transactions.setList(\n                this._nodeAccountIds.list.map((nodeId) =>\n                    this._makeSignedTransaction(nodeId),\n                ),\n            );\n        }\n    }\n\n    /**\n     * Freeze this transaction from future modification to prepare for\n     * signing or serialization.\n     *\n     * @returns {this}\n     */\n    freeze() {\n        return this.freezeWith(null);\n    }\n\n    /**\n     * @param {?AccountId} accountId\n     */\n    _freezeWithAccountId(accountId) {\n        if (this._operatorAccountId == null) {\n            this._operatorAccountId = accountId;\n        }\n    }\n\n    /**\n     * Freeze this transaction from further modification to prepare for\n     * signing or serialization.\n     *\n     * Will use the `Client`, if available, to generate a default Transaction ID and select 1/3\n     * nodes to prepare this transaction for.\n     *\n     * @param {?import(\"../client/Client.js\").default<Channel, *>} client\n     * @returns {this}\n     */\n    freezeWith(client) {\n        // Set sign on demand based on client\n        this._signOnDemand = client != null ? client.signOnDemand : false;\n\n        // Save the operator\n        this._operator = client != null ? client._operator : null;\n        this._freezeWithAccountId(\n            client != null ? client.operatorAccountId : null,\n        );\n\n        // Set max transaction fee to either `this._maxTransactionFee`,\n        // `client._defaultMaxTransactionFee`, or `this._defaultMaxTransactionFee`\n        // in that priority order depending on if `this._maxTransactionFee` has\n        // been set or if `client._defaultMaxTransactionFee` has been set.\n        this._maxTransactionFee =\n            this._maxTransactionFee == null\n                ? client != null && client.defaultMaxTransactionFee != null\n                    ? client.defaultMaxTransactionFee\n                    : this._defaultMaxTransactionFee\n                : this._maxTransactionFee;\n\n        // Determine if transaction ID generation should be enabled.\n        this._regenerateTransactionId =\n            client != null && this._regenerateTransactionId == null\n                ? client.defaultRegenerateTransactionId\n                : this._regenerateTransactionId;\n\n        // Set the node account IDs via client\n        this._setNodeAccountIds(client);\n\n        // Make sure a transaction ID or operator is set.\n        this._setTransactionId();\n\n        // If a client was not provided, we need to make sure the transaction ID already set\n        // validates aginst the client.\n        if (client != null) {\n            for (const transactionId of this._transactionIds.list) {\n                if (transactionId.accountId != null) {\n                    transactionId.accountId.validateChecksum(client);\n                }\n            }\n        }\n\n        // Build a list of transaction IDs so that if a user calls `.transactionId` they'll\n        // get a value, but if they dont' we'll just regenerate transaction IDs during execution\n        this._buildNewTransactionIdList();\n\n        // If sign on demand is disabled we need to build out all the signed transactions\n        if (!this._signOnDemand) {\n            this._buildSignedTransactions();\n        }\n\n        return this;\n    }\n\n    /**\n     * Sign the transaction using a signer\n     *\n     * This is part of the signature provider feature\n     *\n     * @param {Signer} signer\n     * @returns {Promise<this>}\n     */\n    async signWithSigner(signer) {\n        await signer.signTransaction(this);\n        return this;\n    }\n\n    /**\n     * Freeze the transaction using a signer\n     *\n     * This is part of the signature provider feature.\n     *\n     * @param {Signer} signer\n     * @returns {Promise<this>}\n     */\n    async freezeWithSigner(signer) {\n        await signer.populateTransaction(this);\n        this.freeze();\n        return this;\n    }\n\n    /**\n     * Serialize the request into bytes. This will encode all the transactions\n     * into a `proto.TransactionList` and return the encoded protobuf.\n     *\n     * **NOTE**: Does not support sign on demand\n     *\n     * @returns {Uint8Array}\n     */\n    toBytes() {\n        // Sign on demand must be disabled because this is the non-async version and\n        // signing requires awaiting callbacks.\n        this._requireNotSignOnDemand();\n\n        if (this._isFrozen()) {\n            // Locking the transaction IDs and node account IDs is necessary for consistency\n            // between before and after execution\n            this._transactionIds.setLocked();\n            this._nodeAccountIds.setLocked();\n\n            // Build all the transactions without signing\n            this._buildAllTransactions();\n        } else {\n            this._buildIncompleteTransactions();\n        }\n\n        // Construct and encode the transaction list\n        return HieroProto.proto.TransactionList.encode({\n            transactionList: /** @type {HieroProto.proto.ITransaction[]} */ (\n                this._transactions.list\n            ),\n        }).finish();\n    }\n\n    /**\n     * Serialize the transaction into bytes\n     *\n     * **NOTE**: Supports sign on demand\n     *\n     * @returns {Promise<Uint8Array>}\n     */\n    async toBytesAsync() {\n        // If sign on demand is enabled, we don't need to care about being frozen\n        // since we can just regenerate and resign later if some field of the transaction\n        // changes.\n\n        // Locking the transaction IDs and node account IDs is necessary for consistency\n        // between before and after execution\n        this._transactionIds.setLocked();\n        this._nodeAccountIds.setLocked();\n\n        // Build all transactions, and sign them\n        await this._buildAllTransactionsAsync();\n\n        // Lock transaction IDs, and node account IDs\n        this._transactions.setLocked();\n        this._signedTransactions.setLocked();\n\n        // Construct and encode the transaction list\n        return HieroProto.proto.TransactionList.encode({\n            transactionList: /** @type {HieroProto.proto.ITransaction[]} */ (\n                this._transactions.list\n            ),\n        }).finish();\n    }\n\n    /**\n     * Get the transaction hash\n     *\n     * @returns {Promise<Uint8Array>}\n     */\n    async getTransactionHash() {\n        this._requireFrozen();\n\n        // Locking the transaction IDs and node account IDs is necessary for consistency\n        // between before and after execution\n        this._transactionIds.setLocked();\n        this._nodeAccountIds.setLocked();\n\n        await this._buildAllTransactionsAsync();\n\n        this._transactions.setLocked();\n        this._signedTransactions.setLocked();\n\n        return sha384.digest(\n            /** @type {Uint8Array} */ (\n                /** @type {HieroProto.proto.ITransaction} */ (\n                    this._transactions.get(0)\n                ).signedTransactionBytes\n            ),\n        );\n    }\n\n    /**\n     * Get all the transaction hashes\n     *\n     * @returns {Promise<TransactionHashMap>}\n     */\n    async getTransactionHashPerNode() {\n        this._requireFrozen();\n\n        // Locking the transaction IDs and node account IDs is necessary for consistency\n        // between before and after execution\n        this._transactionIds.setLocked();\n        this._nodeAccountIds.setLocked();\n\n        await this._buildAllTransactionsAsync();\n\n        return await TransactionHashMap._fromTransaction(this);\n    }\n\n    /**\n     * Is transaction frozen\n     *\n     * @returns {boolean}\n     */\n    isFrozen() {\n        return this._signedTransactions.length > 0;\n    }\n\n    /**\n     * Get the current transaction ID, and make sure it's not null\n     *\n     * @protected\n     * @returns {TransactionId}\n     */\n    _getTransactionId() {\n        const transactionId = this.transactionId;\n        if (transactionId == null) {\n            throw new Error(\n                \"transaction must have been frozen before getting the transaction ID, try calling `freeze`\",\n            );\n        }\n        return transactionId;\n    }\n\n    /**\n     * @param {Client} client\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars,@typescript-eslint/no-empty-function\n    _validateChecksums(client) {\n        // Do nothing\n    }\n\n    /**\n     * Before we proceed execution, we need to do a couple checks\n     *\n     * @override\n     * @protected\n     * @param {import(\"../client/Client.js\").default<Channel, *>} client\n     * @returns {Promise<void>}\n     */\n    async _beforeExecute(client) {\n        // Assign the account IDs to which the transaction should be sent.\n        this.transactionNodeIds = Object.values(client.network).map(\n            (accountNodeId) => accountNodeId.toString(),\n        );\n\n        if (this._logger) {\n            this._logger.info(\n                `Network used: ${client._network.networkName}`, // eslint-disable-line @typescript-eslint/restrict-template-expressions\n            );\n        }\n\n        // Make sure we're frozen\n        if (!this._isFrozen()) {\n            this.freezeWith(client);\n        }\n\n        // Valid checksums if the option is enabled\n        if (client.isAutoValidateChecksumsEnabled()) {\n            this._validateChecksums(client);\n        }\n\n        // Set the operator if the client has one and the current operator is nullish\n        if (this._operator == null || this._operator == undefined) {\n            this._operator = client != null ? client._operator : null;\n        }\n\n        if (\n            this._operatorAccountId == null ||\n            this._operatorAccountId == undefined\n        ) {\n            this._operatorAccountId =\n                client != null && client._operator != null\n                    ? client._operator.accountId\n                    : null;\n        }\n\n        // If the client has an operator, sign this request with the operator\n        if (this._operator != null) {\n            await this.signWith(\n                this._operator.publicKey,\n                this._operator.transactionSigner,\n            );\n        }\n    }\n\n    /**\n     * Construct a protobuf transaction\n     *\n     * @override\n     * @internal\n     * @returns {Promise<HieroProto.proto.ITransaction>}\n     */\n    async _makeRequestAsync() {\n        // The index for the transaction\n        const index =\n            this._transactionIds.index * this._nodeAccountIds.length +\n            this._nodeAccountIds.index;\n\n        // If sign on demand is disabled we need to simply build that transaction\n        // and return the result, without signing\n        if (!this._signOnDemand) {\n            this._buildTransaction(index);\n            return /** @type {HieroProto.proto.ITransaction} */ (\n                this._transactions.get(index)\n            );\n        }\n\n        // Build and sign a transaction\n        return await this._buildTransactionAsync();\n    }\n\n    /**\n     * Sign a `proto.SignedTransaction` with all the keys\n     *\n     * @private\n     * @returns {Promise<HieroProto.proto.ISignedTransaction>}\n     */\n    async _signTransaction() {\n        const signedTransaction = this._makeSignedTransaction(\n            this._nodeAccountIds.next,\n        );\n\n        const bodyBytes = /** @type {Uint8Array} */ (\n            signedTransaction.bodyBytes\n        );\n\n        for (let j = 0; j < this._publicKeys.length; j++) {\n            const publicKey = this._publicKeys[j];\n            const transactionSigner = this._transactionSigners[j];\n\n            if (transactionSigner == null) {\n                continue;\n            }\n\n            const signature = await transactionSigner(bodyBytes);\n\n            if (signedTransaction.sigMap == null) {\n                signedTransaction.sigMap = {};\n            }\n\n            if (signedTransaction.sigMap.sigPair == null) {\n                signedTransaction.sigMap.sigPair = [];\n            }\n\n            signedTransaction.sigMap.sigPair.push(\n                publicKey._toProtobufSignature(signature),\n            );\n        }\n\n        return signedTransaction;\n    }\n\n    /**\n     * Construct a new transaction ID at the current index\n     *\n     * @private\n     */\n    _buildNewTransactionIdList() {\n        if (this._transactionIds.locked || this._operatorAccountId == null) {\n            return;\n        }\n\n        const transactionId = TransactionId.withValidStart(\n            this._operatorAccountId,\n            Timestamp.generate(),\n        );\n\n        this._transactionIds.set(this._transactionIds.index, transactionId);\n    }\n\n    /**\n     * Build each signed transaction in a loop\n     *\n     * @internal\n     */\n    _buildAllTransactions() {\n        for (let i = 0; i < this._signedTransactions.length; i++) {\n            this._buildTransaction(i);\n        }\n    }\n\n    /**\n     * Build and and sign each transaction in a loop\n     *\n     * This method is primary used in the exist condition methods\n     * which are not `execute()`, e.g. `toBytesAsync()` and `getSignaturesAsync()`\n     *\n     * @private\n     */\n    async _buildAllTransactionsAsync() {\n        if (!this._signOnDemand) {\n            this._buildAllTransactions();\n            return;\n        }\n\n        this._buildSignedTransactions();\n\n        if (this._transactions.locked) {\n            return;\n        }\n\n        for (let i = 0; i < this._signedTransactions.length; i++) {\n            this._transactions.push(await this._buildTransactionAsync());\n        }\n    }\n\n    /**\n     * Build a transaction at a particular index\n     *\n     * @internal\n     * @param {number} index\n     */\n    _buildTransaction(index) {\n        if (this._transactions.length < index) {\n            for (let i = this._transactions.length; i < index; i++) {\n                this._transactions.push(null);\n            }\n        }\n\n        // In case when an incomplete transaction is created, serialized and\n        // deserialized,and then the transaction being frozen, the copy of the\n        // incomplete transaction must be updated in order to be prepared for execution\n        if (this._transactions.list[index] != null) {\n            this._transactions.set(index, {\n                signedTransactionBytes:\n                    HieroProto.proto.SignedTransaction.encode(\n                        this._signedTransactions.get(index),\n                    ).finish(),\n            });\n        }\n\n        this._transactions.setIfAbsent(index, () => {\n            return {\n                signedTransactionBytes:\n                    HieroProto.proto.SignedTransaction.encode(\n                        this._signedTransactions.get(index),\n                    ).finish(),\n            };\n        });\n    }\n\n    /**\n     * Build a trransaction using the current index, where the current\n     * index is determined by `this._nodeAccountIds.index` and\n     * `this._transactionIds.index`\n     *\n     * @private\n     * @returns {Promise<HieroProto.proto.ITransaction>}\n     */\n    async _buildTransactionAsync() {\n        return {\n            signedTransactionBytes: HieroProto.proto.SignedTransaction.encode(\n                await this._signTransaction(),\n            ).finish(),\n        };\n    }\n\n    /**\n     * Determine what execution state we're in.\n     *\n     * @override\n     * @internal\n     * @param {HieroProto.proto.ITransaction} request\n     * @param {HieroProto.proto.ITransactionResponse} response\n     * @returns {[Status, ExecutionState]}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _shouldRetry(request, response) {\n        const { nodeTransactionPrecheckCode } = response;\n\n        // Get the node precheck code, and convert it into an SDK `Status`\n        const status = Status._fromCode(\n            nodeTransactionPrecheckCode != null\n                ? nodeTransactionPrecheckCode\n                : HieroProto.proto.ResponseCodeEnum.OK,\n        );\n\n        if (this._logger) {\n            this._logger.debug(\n                `[${this._getLogId()}] received status ${status.toString()}`,\n            );\n            this._logger.info(\n                `SDK Transaction Status Response: ${status.toString()}`,\n            );\n        }\n\n        // Based on the status what execution state are we in\n        switch (status) {\n            case Status.Busy:\n            case Status.Unknown:\n            case Status.PlatformTransactionNotCreated:\n            case Status.PlatformNotActive:\n                return [status, ExecutionState.Retry];\n            case Status.Ok:\n                return [status, ExecutionState.Finished];\n            case Status.TransactionExpired:\n                if (\n                    this._transactionIds.locked ||\n                    (this._regenerateTransactionId != null &&\n                        !this._regenerateTransactionId)\n                ) {\n                    return [status, ExecutionState.Error];\n                } else {\n                    this._buildNewTransactionIdList();\n                    return [status, ExecutionState.Retry];\n                }\n            default:\n                return [status, ExecutionState.Error];\n        }\n    }\n\n    /**\n     * Map the request and response into a precheck status error\n     *\n     * @override\n     * @internal\n     * @param {HieroProto.proto.ITransaction} request\n     * @param {HieroProto.proto.ITransactionResponse} response\n     * @param {AccountId} nodeId\n     * @returns {Error}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _mapStatusError(request, response, nodeId) {\n        const { nodeTransactionPrecheckCode } = response;\n\n        const status = Status._fromCode(\n            nodeTransactionPrecheckCode != null\n                ? nodeTransactionPrecheckCode\n                : HieroProto.proto.ResponseCodeEnum.OK,\n        );\n        if (this._logger) {\n            this._logger.info(\n                // @ts-ignore\n                `Transaction Error Info: ${status.toString()}, ${this.transactionId.toString()}`, // eslint-disable-line @typescript-eslint/restrict-template-expressions\n            );\n        }\n\n        return new PrecheckStatusError({\n            nodeId,\n            status,\n            transactionId: this._getTransactionId(),\n            contractFunctionResult: null,\n        });\n    }\n\n    /**\n     * Map the request, response, and node account ID into a `TransactionResponse`\n     *\n     * @override\n     * @protected\n     * @param {HieroProto.proto.ITransactionResponse} response\n     * @param {AccountId} nodeId\n     * @param {HieroProto.proto.ITransaction} request\n     * @returns {Promise<TransactionResponse>}\n     */\n    async _mapResponse(response, nodeId, request) {\n        const transactionHash = await sha384.digest(\n            /** @type {Uint8Array} */ (request.signedTransactionBytes),\n        );\n        const transactionId = this._getTransactionId();\n\n        this._transactionIds.advance();\n        if (this._logger) {\n            this._logger.info(\n                `Transaction Info: ${JSON.stringify(\n                    new TransactionResponse({\n                        nodeId,\n                        transactionHash,\n                        transactionId,\n                    }).toJSON(),\n                )}`,\n            );\n        }\n\n        return new TransactionResponse({\n            nodeId,\n            transactionHash,\n            transactionId,\n        });\n    }\n\n    /**\n     * Make a signed transaction given a node account ID\n     *\n     * @internal\n     * @param {?AccountId} nodeId\n     * @returns {HieroProto.proto.ISignedTransaction}\n     */\n    _makeSignedTransaction(nodeId) {\n        const body = this._makeTransactionBody(nodeId);\n        if (this._logger) {\n            this._logger.info(`Transaction Body: ${JSON.stringify(body)}`);\n        }\n        const bodyBytes =\n            HieroProto.proto.TransactionBody.encode(body).finish();\n\n        return {\n            sigMap: {\n                sigPair: [],\n            },\n            bodyBytes,\n        };\n    }\n\n    /**\n     * Make a protobuf transaction body\n     *\n     * @private\n     * @param {?AccountId} nodeId\n     * @returns {HieroProto.proto.ITransactionBody}\n     */\n    _makeTransactionBody(nodeId) {\n        return {\n            [this._getTransactionDataCase()]: this._makeTransactionData(),\n            transactionFee:\n                this._maxTransactionFee != null\n                    ? this._maxTransactionFee.toTinybars()\n                    : null,\n            memo: this._transactionMemo,\n            transactionID:\n                this._transactionIds.current != null\n                    ? this._transactionIds.current._toProtobuf()\n                    : null,\n            nodeAccountID: nodeId != null ? nodeId._toProtobuf() : null,\n            transactionValidDuration: {\n                seconds: Long.fromNumber(this._transactionValidDuration),\n            },\n            maxCustomFees:\n                this._customFeeLimits != null\n                    ? this._customFeeLimits.map((maxCustomFee) =>\n                          maxCustomFee._toProtobuf(),\n                      )\n                    : null,\n        };\n    }\n\n    /**\n     * This method returns a key for the `data` field in a transaction body.\n     * Each transaction overwrite this to make sure when we build the transaction body\n     * we set the right data field.\n     *\n     * @abstract\n     * @protected\n     * @returns {NonNullable<HieroProto.proto.TransactionBody[\"data\"]>}\n     */\n    _getTransactionDataCase() {\n        throw new Error(\"not implemented\");\n    }\n\n    /**\n     * Make a scheduled transaction body\n     * FIXME: Should really call this `makeScheduledTransactionBody` to be consistent\n     *\n     * @internal\n     * @returns {HieroProto.proto.ISchedulableTransactionBody}\n     */\n    _getScheduledTransactionBody() {\n        return {\n            memo: this.transactionMemo,\n            transactionFee:\n                this._maxTransactionFee == null\n                    ? this._defaultMaxTransactionFee.toTinybars()\n                    : this._maxTransactionFee.toTinybars(),\n            [this._getTransactionDataCase()]: this._makeTransactionData(),\n        };\n    }\n\n    /**\n     * Make the transaction body data.\n     *\n     * @abstract\n     * @protected\n     * @returns {object}\n     */\n    _makeTransactionData() {\n        throw new Error(\"not implemented\");\n    }\n\n    /**\n     * FIXME: Why do we have `isFrozen` and `_isFrozen()`?\n     *\n     * @protected\n     * @returns {boolean}\n     */\n    _isFrozen() {\n        return this._signOnDemand || this._signedTransactions.length > 0;\n    }\n\n    /**\n     * Require the transaction to NOT be frozen\n     *\n     * @internal\n     */\n    _requireNotFrozen() {\n        if (this._isFrozen()) {\n            throw new Error(\n                \"transaction is immutable; it has at least one signature or has been explicitly frozen\",\n            );\n        }\n    }\n\n    /**\n     * Require the transaction to have sign on demand disabled\n     *\n     * @internal\n     */\n    _requireNotSignOnDemand() {\n        if (this._signOnDemand) {\n            throw new Error(\n                \"Please use `toBytesAsync()` if `signOnDemand` is enabled\",\n            );\n        }\n    }\n\n    /**\n     * Require the transaction to be frozen\n     *\n     * @internal\n     */\n    _requireFrozen() {\n        if (!this._isFrozen()) {\n            throw new Error(\n                \"transaction must have been frozen before calculating the hash will be stable, try calling `freeze`\",\n            );\n        }\n    }\n\n    /**\n     * Require the transaction to have a single node account ID set\n     *\n     * @internal\n     * @protected\n     */\n    _requireOneNodeAccountId() {\n        if (this._nodeAccountIds.length != 1) {\n            throw \"transaction did not have exactly one node ID set\";\n        }\n    }\n\n    /**\n     * @param {HieroProto.proto.Transaction} request\n     * @returns {Uint8Array}\n     */\n    _requestToBytes(request) {\n        return HieroProto.proto.Transaction.encode(request).finish();\n    }\n\n    /**\n     * @param {HieroProto.proto.TransactionResponse} response\n     * @returns {Uint8Array}\n     */\n    _responseToBytes(response) {\n        return HieroProto.proto.TransactionResponse.encode(response).finish();\n    }\n\n    /**\n     * Removes all signatures from a transaction and collects the removed signatures.\n     *\n     * @param {HieroProto.proto.ISignedTransaction} transaction - The transaction object to process.\n     * @param {string} publicKeyHex - The hexadecimal representation of the public key.\n     * @returns {Uint8Array[]} An array of removed signatures.\n     */\n    _removeSignaturesFromTransaction(transaction, publicKeyHex) {\n        /** @type {Uint8Array[]} */\n        const removedSignatures = [];\n\n        if (!transaction.sigMap || !transaction.sigMap.sigPair) {\n            return [];\n        }\n\n        transaction.sigMap.sigPair = transaction.sigMap.sigPair.filter(\n            (sigPair) => {\n                const shouldRemove = this._shouldRemoveSignature(\n                    sigPair,\n                    publicKeyHex,\n                );\n                const signature = sigPair.ed25519 ?? sigPair.ECDSASecp256k1;\n\n                if (shouldRemove && signature) {\n                    removedSignatures.push(signature);\n                }\n\n                return !shouldRemove;\n            },\n        );\n\n        return removedSignatures;\n    }\n\n    /**\n     * Determines whether a signature should be removed based on the provided public key.\n     *\n     * @param {HieroProto.proto.ISignaturePair} sigPair - The signature pair object that contains\n     *        the public key prefix and signature to be evaluated.\n     * @param {string} publicKeyHex - The hexadecimal representation of the public key to compare against.\n     * @returns {boolean} `true` if the public key prefix in the signature pair matches the provided public key,\n     *          indicating that the signature should be removed; otherwise, `false`.\n     */\n    _shouldRemoveSignature = (sigPair, publicKeyHex) => {\n        const sigPairPublicKeyHex = hex.encode(\n            sigPair?.pubKeyPrefix || new Uint8Array(),\n        );\n\n        const matchesPublicKey = sigPairPublicKeyHex === publicKeyHex;\n\n        return matchesPublicKey;\n    };\n\n    /**\n     * Collects all signatures from signed transactions and returns them in a format keyed by PublicKey.\n     *\n     * @returns { Map<PublicKey, Uint8Array[]> } The collected signatures keyed by PublicKey.\n     */\n    _collectSignaturesByPublicKey() {\n        /** @type {  Map<PublicKey, Uint8Array[]>} */\n        const collectedSignatures = new Map();\n        /** @type { Record<string, PublicKey> } */\n        const publicKeyMap = {}; // Map to hold string representation of the PublicKey object\n\n        // Iterate over the signed transactions and collect signatures\n        for (const transaction of this._signedTransactions.list) {\n            if (!(transaction.sigMap && transaction.sigMap.sigPair)) {\n                return new Map();\n            }\n\n            // Collect the signatures\n            for (const sigPair of transaction.sigMap.sigPair) {\n                const signature = sigPair.ed25519 ?? sigPair.ECDSASecp256k1;\n\n                if (!signature || !sigPair.pubKeyPrefix) {\n                    return new Map();\n                }\n\n                const publicKeyStr = hex.encode(sigPair.pubKeyPrefix);\n                let publicKeyObj = publicKeyMap[publicKeyStr];\n\n                // If the PublicKey instance for this string representation doesn't exist, create and store it\n                if (!publicKeyObj) {\n                    publicKeyObj = PublicKey.fromString(publicKeyStr);\n                    publicKeyMap[publicKeyStr] = publicKeyObj;\n                }\n\n                // Initialize the structure for this publicKey if it doesn't exist\n                if (!collectedSignatures.has(publicKeyObj)) {\n                    collectedSignatures.set(publicKeyObj, []);\n                }\n\n                const existingSignatures =\n                    collectedSignatures.get(publicKeyObj);\n\n                // Add the signature to the corresponding public key\n                if (existingSignatures) {\n                    existingSignatures.push(signature);\n                }\n            }\n        }\n\n        return collectedSignatures;\n    }\n}\n\n/**\n * This is essentially a registry/cache for a callback that creates a `ScheduleCreateTransaction`\n *\n * @type {(() => ScheduleCreateTransaction)[]}\n */\nexport const SCHEDULE_CREATE_TRANSACTION = [];\n"],"names":["DEFAULT_AUTO_RENEW_PERIOD","Long","fromValue","DEFAULT_RECORD_THRESHOLD","Hbar","fromTinybars","fromString","CHUNK_SIZE","TRANSACTION_REGISTRY","Map","Transaction","Executable","constructor","super","this","_transactions","List","_signedTransactions","_signerPublicKeys","Set","_transactionValidDuration","_defaultMaxTransactionFee","_customFeeLimits","_maxTransactionFee","_transactionMemo","_transactionIds","_publicKeys","_transactionSigners","_regenerateTransactionId","fromBytes","bytes","signedTransactions","transactionIds","nodeIds","transactionIdStrings","nodeIdStrings","bodies","list","HieroProto","proto","TransactionList","decode","transactionList","length","transaction","signedTransactionBytes","push","SignedTransaction","encode","sigMap","bodyBytes","finish","Error","body","TransactionBody","transactionID","transactionId","TransactionId","_fromProtobuf","includes","toString","nodeAccountID","nodeAccountId","AccountId","data","signedTransaction","fromProtobuf","get","schedule","_requireNotFrozen","SCHEDULE_CREATE_TRANSACTION","_setScheduledTransaction","_fromProtobufTransactions","transactions","i","j","util.compare","zero","equals","splice","setList","_nodeAccountIds","transactionValidDuration","seconds","toInt","transactionFee","maxCustomFees","map","fee","CustomFeeLimit","memo","tx","sigPair","add","hex.encode","PublicKey","setNodeAccountIds","setTransactionValidDuration","validDuration","maxTransactionFee","setMaxTransactionFee","regenerateTransactionId","setRegenerateTransactionId","transactionMemo","setTransactionMemo","isEmpty","setLocked","current","setTransactionId","getRequiredChunks","sign","privateKey","signWith","publicKey","message","Promise","resolve","transactionSigner","_signOnDemand","_requireFrozen","publicKeyData","toBytesRaw","publicKeyHex","has","clear","signature","_toProtobufSignature","signWithOperator","client","operator","_operator","_isFrozen","freezeWith","addSignature","signatureMap","isFrozen","freeze","index","nodeSignatures","transactionSignatures","removeSignature","removedSignatures","removedSignaturesFromTransaction","_removeSignaturesFromTransaction","delete","filter","key","pop","removeAllSignatures","_collectSignaturesByPublicKey","getSignatures","_requireNotSignOnDemand","_buildAllTransactions","SignatureMap","_fromTransaction","getSignaturesAsync","_buildAllTransactionsAsync","_setTransactionId","_operatorAccountId","_setNodeAccountIds","_network","getNodeAccountIdsForExecute","_buildSignedTransactions","locked","nodeId","_makeSignedTransaction","_buildIncompleteTransactions","_freezeWithAccountId","accountId","signOnDemand","operatorAccountId","defaultMaxTransactionFee","defaultRegenerateTransactionId","validateChecksum","_buildNewTransactionIdList","signWithSigner","signer","signTransaction","freezeWithSigner","populateTransaction","toBytes","toBytesAsync","getTransactionHash","sha384.digest","getTransactionHashPerNode","TransactionHashMap","_getTransactionId","_validateChecksums","_beforeExecute","transactionNodeIds","Object","values","network","accountNodeId","_logger","info","networkName","isAutoValidateChecksumsEnabled","undefined","_makeRequestAsync","_buildTransactionAsync","_buildTransaction","_signTransaction","next","withValidStart","Timestamp","generate","set","setIfAbsent","_shouldRetry","request","response","nodeTransactionPrecheckCode","status","Status","_fromCode","ResponseCodeEnum","OK","debug","_getLogId","Busy","Unknown","PlatformTransactionNotCreated","PlatformNotActive","ExecutionState","Retry","Ok","Finished","TransactionExpired","_mapStatusError","PrecheckStatusError","contractFunctionResult","_mapResponse","transactionHash","advance","JSON","stringify","TransactionResponse","toJSON","_makeTransactionBody","_getTransactionDataCase","_makeTransactionData","toTinybars","_toProtobuf","fromNumber","maxCustomFee","_getScheduledTransactionBody","_requireOneNodeAccountId","_requestToBytes","_responseToBytes","shouldRemove","_shouldRemoveSignature","ed25519","ECDSASecp256k1","pubKeyPrefix","Uint8Array","collectedSignatures","publicKeyMap","publicKeyStr","publicKeyObj","existingSignatures"],"mappings":"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"}