{"version":3,"file":"TransactionResponse.js","sources":["../../src/transaction/TransactionResponse.js"],"sourcesContent":["// SPDX-License-Identifier: Apache-2.0\n\nimport ReceiptStatusError from \"../ReceiptStatusError.js\";\nimport Status from \"../Status.js\";\nimport TransactionReceiptQuery from \"./TransactionReceiptQuery.js\";\nimport TransactionRecordQuery from \"./TransactionRecordQuery.js\";\nimport AccountId from \"../account/AccountId.js\";\nimport TransactionId from \"./TransactionId.js\";\nimport * as hex from \"../encoding/hex.js\";\n\n/**\n * @typedef {import(\"../client/Client.js\").default<*, *>} Client\n * @typedef {import(\"./TransactionReceipt.js\").default} TransactionReceipt\n * @typedef {import(\"./TransactionRecord.js\").default} TransactionRecord\n * @typedef {import(\"../Signer.js\").Signer} Signer\n */\n\n/**\n * @typedef {object} TransactionResponseJSON\n * @property {string} nodeId\n * @property {string} transactionHash\n * @property {string} transactionId\n */\n\n/**\n * When the client sends the node a transaction of any kind, the node\n * replies with this, which simply says that the transaction passed\n * the pre-check (so the node will submit it to the network) or it failed\n * (so it won't). To learn the consensus result, the client should later\n * obtain a receipt (free), or can buy a more detailed record (not free).\n * <br>\n * See <a href=\"https://docs.hedera.com/guides/docs/hedera-api/miscellaneous/transactionresponse\">Hedera Documentation</a>\n */\nexport default class TransactionResponse {\n    /**\n     * @internal\n     * @param {object} props\n     * @param {AccountId} props.nodeId\n     * @param {Uint8Array} props.transactionHash\n     * @param {TransactionId} props.transactionId\n     */\n    constructor(props) {\n        /** @readonly */\n        this.nodeId = props.nodeId;\n\n        /** @readonly */\n        this.transactionHash = props.transactionHash;\n\n        /** @readonly */\n        this.transactionId = props.transactionId;\n\n        Object.freeze(this);\n    }\n\n    /**\n     * @param {TransactionResponseJSON} json\n     * @returns {TransactionResponse}\n     */\n    static fromJSON(json) {\n        return new TransactionResponse({\n            nodeId: AccountId.fromString(json.nodeId),\n            transactionHash: hex.decode(json.transactionHash),\n            transactionId: TransactionId.fromString(json.transactionId),\n        });\n    }\n\n    /**\n     * @param {Client} client\n     * @returns {Promise<TransactionReceipt>}\n     */\n    async getReceipt(client) {\n        const receipt = await this.getReceiptQuery().execute(client);\n\n        if (\n            receipt.status !== Status.Success &&\n            receipt.status !== Status.FeeScheduleFilePartUploaded\n        ) {\n            throw new ReceiptStatusError({\n                transactionReceipt: receipt,\n                status: receipt.status,\n                transactionId: this.transactionId,\n            });\n        }\n\n        return receipt;\n    }\n\n    /**\n     * getRecord is calling getReceipt and in case the receipt status code is not OK, only the receipt is returned.\n     *\n     * @param {Client} client\n     * @returns {Promise<TransactionRecord>}\n     */\n    async getRecord(client) {\n        await this.getReceipt(client);\n\n        return this.getRecordQuery().execute(client);\n    }\n\n    /**\n     * getVerboseRecord is calling getReceipt and in case the receipt status code is not OK, the record is returned.\n     *\n     * @param {Client} client\n     * @returns {Promise<TransactionRecord>}\n     */\n    async getVerboseRecord(client) {\n        try {\n            // The receipt needs to be called in order to wait for transaction to be included in the consensus. Otherwise we are going to get \"DUPLICATE_TRANSACTION\".\n            await this.getReceiptQuery().execute(client);\n            return this.getRecordQuery().execute(client);\n        } catch (e) {\n            return this.getRecordQuery().execute(client);\n        }\n    }\n\n    /**\n     * @param {Signer} signer\n     * @returns {Promise<TransactionReceipt>}\n     */\n    async getReceiptWithSigner(signer) {\n        const receipt = await this.getReceiptQuery().executeWithSigner(signer);\n\n        if (receipt.status !== Status.Success) {\n            throw new ReceiptStatusError({\n                transactionReceipt: receipt,\n                status: receipt.status,\n                transactionId: this.transactionId,\n            });\n        }\n\n        return receipt;\n    }\n\n    /**\n     * @param {Signer} signer\n     * @returns {Promise<TransactionRecord>}\n     */\n    async getRecordWithSigner(signer) {\n        await this.getReceiptWithSigner(signer);\n\n        return this.getRecordQuery().executeWithSigner(signer);\n    }\n\n    /**\n     * @returns {TransactionReceiptQuery}\n     */\n    getReceiptQuery() {\n        return new TransactionReceiptQuery()\n            .setTransactionId(this.transactionId)\n            .setNodeAccountIds([this.nodeId]);\n    }\n\n    /**\n     * @returns {TransactionRecordQuery}\n     */\n    getRecordQuery() {\n        return new TransactionRecordQuery()\n            .setTransactionId(this.transactionId)\n            .setNodeAccountIds([this.nodeId]);\n    }\n\n    /**\n     * @returns {TransactionResponseJSON}\n     */\n    toJSON() {\n        return {\n            nodeId: this.nodeId.toString(),\n            transactionHash: hex.encode(this.transactionHash),\n            transactionId: this.transactionId.toString(),\n        };\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return JSON.stringify(this.toJSON());\n    }\n}\n"],"names":["TransactionResponse","constructor","props","this","nodeId","transactionHash","transactionId","Object","freeze","fromJSON","json","AccountId","fromString","hex.decode","TransactionId","getReceipt","client","receipt","getReceiptQuery","execute","status","Status","Success","FeeScheduleFilePartUploaded","ReceiptStatusError","transactionReceipt","getRecord","getRecordQuery","getVerboseRecord","e","getReceiptWithSigner","signer","executeWithSigner","getRecordWithSigner","TransactionReceiptQuery","setTransactionId","setNodeAccountIds","TransactionRecordQuery","toJSON","toString","hex.encode","JSON","stringify"],"mappings":"4RAiCe,MAAMA,EAQjB,WAAAC,CAAYC,GAERC,KAAKC,OAASF,EAAME,OAGpBD,KAAKE,gBAAkBH,EAAMG,gBAG7BF,KAAKG,cAAgBJ,EAAMI,cAE3BC,OAAOC,OAAOL,KACtB,CAMI,eAAOM,CAASC,GACZ,OAAO,IAAIV,EAAoB,CAC3BI,OAAQO,EAAUC,WAAWF,EAAKN,QAClCC,gBAAiBQ,EAAWH,EAAKL,iBACjCC,cAAeQ,EAAcF,WAAWF,EAAKJ,gBAEzD,CAMI,gBAAMS,CAAWC,GACb,MAAMC,QAAgBd,KAAKe,kBAAkBC,QAAQH,GAErD,GACIC,EAAQG,SAAWC,EAAOC,SAC1BL,EAAQG,SAAWC,EAAOE,4BAE1B,MAAM,IAAIC,EAAmB,CACzBC,mBAAoBR,EACpBG,OAAQH,EAAQG,OAChBd,cAAeH,KAAKG,gBAI5B,OAAOW,CACf,CAQI,eAAMS,CAAUV,GAGZ,aAFMb,KAAKY,WAAWC,GAEfb,KAAKwB,iBAAiBR,QAAQH,EAC7C,CAQI,sBAAMY,CAAiBZ,GACnB,IAGI,aADMb,KAAKe,kBAAkBC,QAAQH,GAC9Bb,KAAKwB,iBAAiBR,QAAQH,EACxC,CAAC,MAAOa,GACL,OAAO1B,KAAKwB,iBAAiBR,QAAQH,EACjD,CACA,CAMI,0BAAMc,CAAqBC,GACvB,MAAMd,QAAgBd,KAAKe,kBAAkBc,kBAAkBD,GAE/D,GAAId,EAAQG,SAAWC,EAAOC,QAC1B,MAAM,IAAIE,EAAmB,CACzBC,mBAAoBR,EACpBG,OAAQH,EAAQG,OAChBd,cAAeH,KAAKG,gBAI5B,OAAOW,CACf,CAMI,yBAAMgB,CAAoBF,GAGtB,aAFM5B,KAAK2B,qBAAqBC,GAEzB5B,KAAKwB,iBAAiBK,kBAAkBD,EACvD,CAKI,eAAAb,GACI,OAAO,IAAIgB,GACNC,iBAAiBhC,KAAKG,eACtB8B,kBAAkB,CAACjC,KAAKC,QACrC,CAKI,cAAAuB,GACI,OAAO,IAAIU,GACNF,iBAAiBhC,KAAKG,eACtB8B,kBAAkB,CAACjC,KAAKC,QACrC,CAKI,MAAAkC,GACI,MAAO,CACHlC,OAAQD,KAAKC,OAAOmC,WACpBlC,gBAAiBmC,EAAWrC,KAAKE,iBACjCC,cAAeH,KAAKG,cAAciC,WAE9C,CAKI,QAAAA,GACI,OAAOE,KAAKC,UAAUvC,KAAKmC,SACnC"}