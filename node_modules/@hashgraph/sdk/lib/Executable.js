import t from"./grpc/GrpcServiceError.js";import e from"./grpc/GrpcStatus.js";import o from"./transaction/List.js";import{encode as n}from"./encoding/hex.js";import r from"./http/HttpError.js";import s from"./Status.js";import i from"./MaxAttemptsOrTimeoutError.js";const c={Finished:"Finished",Retry:"Retry",Error:"Error"},a=/\brst[^0-9a-zA-Z]stream\b/i,h=10;class u{constructor(){this._maxAttempts=10,this._nodeAccountIds=new o,this.transactionNodeIds=[],this._signOnDemand=!1,this._minBackoff=null,this._maxBackoff=8e3,this._operator=null,this._requestTimeout=null,this._grpcDeadline=null,this._logger=null}get nodeAccountIds(){return this._nodeAccountIds.isEmpty?null:(this._nodeAccountIds.setLocked(),this._nodeAccountIds.list)}setNodeAccountIds(t){return this._nodeAccountIds.setList(t).setLocked(),this}get maxRetries(){return console.warn("Deprecated: use maxAttempts instead"),this.maxAttempts}setMaxRetries(t){return console.warn("Deprecated: use setMaxAttempts() instead"),this.setMaxAttempts(t)}get maxAttempts(){return this._maxAttempts}setMaxAttempts(t){return this._maxAttempts=t,this}get grpcDeadline(){return this._grpcDeadline}setGrpcDeadline(t){return this._grpcDeadline=t,this}setMinBackoff(t){if(null==t)throw new Error("minBackoff cannot be null.");if(null!=this._maxBackoff&&t>this._maxBackoff)throw new Error("minBackoff cannot be larger than maxBackoff.");return this._minBackoff=t,this}get minBackoff(){return this._minBackoff}setMaxBackoff(t){if(null==t)throw new Error("maxBackoff cannot be null.");if(null!=this._minBackoff&&t<this._minBackoff)throw new Error("maxBackoff cannot be smaller than minBackoff.");return this._maxBackoff=t,this}get maxBackoff(){return this._maxBackoff}_beforeExecute(t){throw new Error("not implemented")}_makeRequestAsync(){throw new Error("not implemented")}_mapStatusError(t,e,o){throw new Error("not implemented")}_mapResponse(t,e,o){throw new Error("not implemented")}_execute(t,e){throw new Error("not implemented")}_getTransactionId(){throw new Error("not implemented")}_getLogId(){throw new Error("not implemented")}_requestToBytes(t){throw new Error("not implemented")}_responseToBytes(t){throw new Error("not implemented")}_shouldRetry(t,e){throw new Error("not implemented")}_shouldRetryExceptionally(o){return!(o instanceof t)||(o.status._code===e.Timeout._code||o.status._code===e.Unavailable._code||o.status._code===e.ResourceExhausted._code||o.status._code===e.GrpcWeb._code||o.status._code===e.Internal._code&&a.test(o.message))}_setOperatorWith(t,e,o){return this._operator={transactionSigner:o,accountId:t,publicKey:e},this}async executeWithSigner(t){return t.call(this)}async execute(e,o){const a=null!=e.network["127.0.0.1:50211"];this._logger=null==this._logger?null!=e._logger?e._logger:null:this._logger,null==this._requestTimeout&&(this._requestTimeout=null!=o?o:e.requestTimeout),await this._beforeExecute(e),null==this._maxBackoff&&(this._maxBackoff=e.maxBackoff),null==this._minBackoff&&(this._minBackoff=e.minBackoff);const h=Date.now();let u=null;const l=a?1e3:e._maxAttempts??this._maxAttempts;if(this.transactionNodeIds.length){const t=this._nodeAccountIds.list.map((t=>t.toString()));if(!this.transactionNodeIds.some((e=>t.includes(e)))){const e=t.length>2?`${t.slice(0,2).join(", ")} ...`:t.join(", "),o=1===t.length;throw new Error(`Attempting to execute a transaction against node${o?"":"s"} ${e}, which ${o?"is":"are"} not included in the Client's node list. Please review your Client configuration.`)}}for(let o=1;o<=l;o+=1){if(null!=this._requestTimeout&&h+this._requestTimeout<=Date.now())throw new i("timeout exceeded",this._nodeAccountIds.isEmpty?"No node account ID set":this._nodeAccountIds.current.toString());let m,g;if(this._nodeAccountIds.isEmpty?(g=e._network.getNode(),m=g.accountId,this._nodeAccountIds.setList([m])):(m=this._nodeAccountIds.current,g=e._network.getNode(m)),null==g)throw new Error(`NodeAccountId not recognized: ${m.toString()}`);if(this.transactionNodeIds.length){if(!this.transactionNodeIds.includes(m.toString())){console.error(`Attempting to execute a transaction against node ${m.toString()}, which is not included in the Client's node list. Please review your Client configuration.`),this._nodeAccountIds.advance();continue}}const _=this._getLogId();this._logger&&this._logger.debug(`[${_}] Node AccountID: ${g.accountId.toString()}, IP: ${g.address.toString()}`);const f=g.getChannel(),p=await this._makeRequestAsync();let w;if(!g.isHealthy()){if(this._nodeAccountIds.index===this._nodeAccountIds.list.length-1||this._nodeAccountIds.length<=1)throw new Error(`Network connectivity issue: All nodes are unhealthy. Original node list: ${this._nodeAccountIds.list.join(", ")}`);this._logger&&this._logger.debug(`[${_}] Node is not healthy, trying the next node.`),this._nodeAccountIds.advance();continue}this._nodeAccountIds.advance();try{const t=[];null!=this._grpcDeadline&&t.push(new Promise(((t,e)=>setTimeout((()=>e(new Error("grpc deadline exceeded"))),this._grpcDeadline)))),this._logger&&this._logger.trace(`[${this._getLogId()}] sending protobuf ${n(this._requestToBytes(p))}`),t.push(this._execute(f,p)),w=await Promise.race(t)}catch(n){const s=t._fromResponse(n);if(u=s,this._logger&&this._logger.debug(`[${_}] received error ${JSON.stringify(s)}`),(s instanceof t||s instanceof r)&&this._shouldRetryExceptionally(s)&&o<=l){this._logger&&this._logger.debug(`[${this._getLogId()}] node with accountId: ${g.accountId.toString()} and proxy IP: ${g.address.toString()} is unhealthy`),e._network.increaseBackoff(g);continue}throw n}this._logger&&this._logger.trace(`[${this._getLogId()}] sending protobuf ${n(this._responseToBytes(w))}`),e._network.decreaseBackoff(g);const[x,I]=this._shouldRetry(p,w);switch(x.toString()!==s.Ok.toString()&&x.toString()!==s.Success.toString()&&(u=x),I){case c.Retry:await d(a,o,this._minBackoff,this._maxBackoff);continue;case c.Finished:return this._mapResponse(w,m,p);case c.Error:throw this._mapStatusError(p,w,m);default:throw new Error("(BUG) non-exhaustive switch statement for `ExecutionState`")}}throw new i(`max attempts of ${l.toString()} was reached for request with last error being: ${null!=u?u.toString():""}`,this._nodeAccountIds.current.toString())}toBytes(){throw new Error("not implemented")}setLogger(t){return this._logger=t,this}get logger(){return this._logger}}function d(t,e,o,n){if(t)return new Promise((t=>setTimeout(t,o)));const r=Math.min(Math.floor(o*Math.pow(2,e)),n);return new Promise((t=>setTimeout(t,r)))}export{h as DEFAULT_MAX_ATTEMPTS,c as ExecutionState,a as RST_STREAM,u as default};
//# sourceMappingURL=Executable.js.map
