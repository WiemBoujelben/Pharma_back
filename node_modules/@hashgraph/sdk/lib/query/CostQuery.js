import e from"../transaction/TransactionId.js";import t from"../Hbar.js";import r from"../Executable.js";import o from"../account/AccountId.js";import{COST_QUERY as s,_makePaymentTransaction as n}from"./Query.js";import*as a from"@hashgraph/proto";class u extends r{constructor(e){super(),this._query=e,this._grpcDeadline=e._grpcDeadline,this._requestTimeout=e._requestTimeout,this._nodeAccountIds=e._nodeAccountIds.clone(),this._operator=e._operator,this._header=null}_getTransactionId(){return this._query._getTransactionId()}_getLogId(){return`CostQuery:${this._query._getLogId()}`}async _beforeExecute(r){if(null==r)throw new Error("Cannot do CostQuery without Client");const s=null!=this._operator?this._operator:r._operator;if(null==s)throw new Error("`client` must have an `operator` or an explicit payment transaction must be provided");this._query._nodeAccountIds.isEmpty&&this._query._nodeAccountIds.setList(r._network.getNodeAccountIdsForExecute());const u=e.generate(s.accountId);null==this._query.paymentTransactionId&&this._query.setPaymentTransactionId(u);const i=this._getLogId(),_=new o(0),c=e.generate(new o(0)),h=new t(0);this._logger&&this._logger.debug(`[${i}] making a payment transaction for node ${_.toString()} and transaction ID ${c.toString()} with amount ${h.toString()}`),this._header={payment:await n(c,new o(0),s,h),responseType:a.proto.ResponseType.COST_ANSWER}}_makeRequestAsync(){return Promise.resolve(this._query._onMakeRequest(this._header))}_shouldRetry(e,t){return this._query._shouldRetry(e,t)}_mapStatusError(e,t,r){return this._query._mapStatusError(e,t,r)}_mapResponse(e,r,o){const s=this._query._mapResponseHeader(e).cost;return Promise.resolve(t.fromTinybars(s))}_execute(e,t){return this._query._execute(e,t)}_requestToBytes(e){return this._query._requestToBytes(e)}_responseToBytes(e){return this._query._responseToBytes(e)}}s.push((e=>new u(e)));export{u as default};
//# sourceMappingURL=CostQuery.js.map
