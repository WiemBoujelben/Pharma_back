import t from"../Status.js";import e from"../account/AccountId.js";import n from"../Hbar.js";import o,{ExecutionState as s}from"../Executable.js";import r from"../transaction/TransactionId.js";import*as a from"@hashgraph/proto";import i from"../PrecheckStatusError.js";import u from"../MaxQueryPaymentExceeded.js";import c from"long";const d=new Map;class h extends o{constructor(){super(),this._paymentTransactionId=null,this._paymentTransactions=[],this._queryPayment=null,this._maxQueryPayment=null,this._timestamp=Date.now()}static fromBytes(t){const e=a.proto.Query.decode(t);if(null==e.query)throw new Error("(BUG) query.query was not set in the protobuf");const n=d.get(e.query);if(null==n)throw new Error(`(BUG) Query.fromBytes() not implemented for type ${e.query}`);return n(e)}toBytes(){return a.proto.Query.encode(this._makeRequest()).finish()}setQueryPayment(t){return this._queryPayment=t,this}setMaxQueryPayment(t){return this._maxQueryPayment=t,this}async getCost(t){if(this._nodeAccountIds.isEmpty&&this._nodeAccountIds.setList(t._network.getNodeAccountIdsForExecute()),1!=y.length)throw new Error("CostQuery has not been loaded yet");this._timestamp=Date.now();const e=await y[0](this).execute(t);return n.fromTinybars(e._valueInTinybar.multipliedBy(1.1).toFixed(0))}setPaymentTransactionId(t){return this._paymentTransactionId=t,this}get paymentTransactionId(){return this._paymentTransactionId}_getTransactionId(){if(null==this._paymentTransactionId)throw new Error("Query.PaymentTransactionId was not set duration execution");return this._paymentTransactionId}_isPaymentRequired(){return!0}_validateChecksums(t){}async _beforeExecute(t){if(this._paymentTransactions.length>0)return;if(t.isAutoValidateChecksumsEnabled()&&this._validateChecksums(t),this._nodeAccountIds.isEmpty&&this._nodeAccountIds.setList(t._network.getNodeAccountIdsForExecute()),this._operator=null!=this._operator?this._operator:t._operator,this._isPaymentRequired()){if(this.transactionNodeIds=Object.values(t.network).map((t=>t.toString())),null==this._operator)throw new Error("`client` must have an `operator` or an explicit payment transaction must be provided");this._paymentTransactionId=r.generate(this._operator.accountId)}else this._paymentTransactionId=r.generate(new e(0));let o=new n(0);const s=null!=this._maxQueryPayment?this._maxQueryPayment:t.defaultMaxQueryPayment;if(null!=this._queryPayment)o=this._queryPayment;else if(0===this._paymentTransactions.length&&this._isPaymentRequired()){const e=await this.getCost(t);if(s.toTinybars().toInt()<e.toTinybars().toInt())throw new u(e,s);o=e,this._logger&&this._logger.debug(`[${this._getLogId()}] received cost for query ${o.toString()}`)}this._queryPayment=o,this._timestamp=Date.now(),this._nodeAccountIds.setLocked();for(const t of this._nodeAccountIds.list){const e=this._getLogId(),n=this._paymentTransactionId,o=this._queryPayment;this._logger&&this._logger.debug(`[${e}] making a payment transaction for node ${t.toString()} and transaction ID ${n.toString()} with amount ${o.toString()}`),this._paymentTransactions.push(await m(n,t,this._isPaymentRequired()?this._operator:null,o))}}_mapResponseHeader(t){throw new Error("not implemented")}_makeRequestHeader(){let t={};return this._isPaymentRequired()&&this._paymentTransactions.length>0&&(t={responseType:a.proto.ResponseType.ANSWER_ONLY,payment:this._paymentTransactions[this._nodeAccountIds.index]}),t}_onMakeRequest(t){throw new Error("not implemented")}_makeRequest(){let t={};return this._isPaymentRequired()&&null!=this._paymentTransactions&&(t={payment:this._paymentTransactions[this._nodeAccountIds.index],responseType:a.proto.ResponseType.ANSWER_ONLY}),this._onMakeRequest(t)}async _makeRequestAsync(){let t={responseType:a.proto.ResponseType.ANSWER_ONLY};const n=this._getLogId(),o=this._nodeAccountIds.current,s=r.generate(this._operator?this._operator.accountId:new e(0)),i=this._queryPayment;return this._logger&&this._logger.debug(`[${n}] making a payment transaction for node ${o.toString()} and transaction ID ${s.toString()} with amount ${i.toString()}`),t.payment=await m(s,o,this._isPaymentRequired()?this._operator:null,i),this._onMakeRequest(t)}_shouldRetry(e,n){const{nodeTransactionPrecheckCode:o}=this._mapResponseHeader(n),r=t._fromCode(null!=o?o:a.proto.ResponseCodeEnum.OK);switch(this._logger&&this._logger.debug(`[${this._getLogId()}] received status ${r.toString()}`),r){case t.Busy:case t.Unknown:case t.PlatformTransactionNotCreated:case t.PlatformNotActive:return[r,s.Retry];case t.Ok:return[r,s.Finished];default:return[r,s.Error]}}_mapStatusError(e,n,o){const{nodeTransactionPrecheckCode:s}=this._mapResponseHeader(n),r=t._fromCode(null!=s?s:a.proto.ResponseCodeEnum.OK);return new i({nodeId:o,status:r,transactionId:this._getTransactionId(),contractFunctionResult:null})}_requestToBytes(t){return a.proto.Query.encode(t).finish()}_responseToBytes(t){return a.proto.Response.encode(t).finish()}}async function m(t,o,s,r){const i=[];null!=s?(i.push({accountID:s.accountId._toProtobuf(),amount:r.negated().toTinybars()}),i.push({accountID:o._toProtobuf(),amount:r.toTinybars()})):(i.push({accountID:new e(0)._toProtobuf(),amount:r.negated().toTinybars()}),i.push({accountID:o._toProtobuf(),amount:r.toTinybars()}));const u={transactionID:t._toProtobuf(),nodeAccountID:o._toProtobuf(),transactionFee:new n(1).toTinybars(),transactionValidDuration:{seconds:c.fromNumber(120)},cryptoTransfer:{transfers:{accountAmounts:i}}},d={bodyBytes:a.proto.TransactionBody.encode(u).finish()};if(null!=s){const t=await s.transactionSigner(d.bodyBytes);d.sigMap={sigPair:[s.publicKey._toProtobufSignature(t)]}}return{signedTransactionBytes:a.proto.SignedTransaction.encode(d).finish()}}const y=[];export{y as COST_QUERY,d as QUERY_REGISTRY,m as _makePaymentTransaction,h as default};
//# sourceMappingURL=Query.js.map
